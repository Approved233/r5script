


global function ShGRX_LevelInit
global function ShGRX_RegisterItemFlavor


global function ShGRX_LevelShutdown
#if DEV
global function PrintItemPurchasabilityForGRXRef
#endif



global function IsValidItemFlavorGRXIndex
global function GetGRXIndexByGRXRef
global function GetItemFlavorByGRXIndex
global function ItemFlavor_GetGRXMode
global function ItemFlavor_GetGRXIndex
global function ItemFlavor_GetGRXAlias
global function ItemFlavor_GetGRXOwnershipTarget
global function ItemFlavor_GetGRXOwnershipTargettedBy
global function ItemFlavor_GetGRXMultipleOwnershipRequirementsList
global function ItemFlavor_GetGRXMultipleOwnershipTarget
global function GRXCurrency_RegisterNewCurrencyAssetInEventSlot
global function GRXCurrency_GetCurrencyIndex
global function GRXCurrency_GetPurchaseSound
global function GRXCurrency_GetPreviewModel
global function GRXCurrency_GetRewardIcon
global function GRXCurrencyBundle_GetCurrencyFlav
global function GRXCurrencyBundle_GetValue
global function AccountFlag_GetPreviewModel
global function AccountFlag_GetRewardIcon
global function GRX_IsInventoryReady
global function GRX_HasInventoryEverBeenReady
global function GRX_GetNumberOfOwnedItemsByPlayer
global function GRX_IsItemOwnedByPlayer
global function GRX_IsItemOwnedByPlayer_AllowOutOfDateData
global function GRX_GetPlayerEdition
global function GRX_IsOfferRestricted
global function GRXPack_IsEphemeral
global function GRXPack_IsExpectedToContainSingleItemWithCurrency
global function GRXPack_GetTickModel
global function GRXPack_GetTickModelSkin
global function GRXPack_GetPackContents

global function GRX_GetStickerPacksWithRewards
global function GRXPack_GetStickerCompletionRewardSequence
global function GRXPack_PlayerOwnsAllItemsInPack
global function GRXPack_GetStickerCompletionRewardPack

#if DEV
global function DEV_GetItemFlavorByGRXRef
global function DEV_IsValidGRXRef
#endif



global function GRXOffer_IsFullyClaimed

global function GRXOffer_IsPurchaseLimitReached
global function GRXOffer_IsEligibleForPurchase
global function GRXOffer_IsOfferOnlyGiftable
global function GRXOffer_RemainingOfferPurchaseCount

global int OFFER_HAS_NO_LIMIT = -1

global function GRXOffer_GetOwnedItemsCount
global function GRXOffer_GetActiveBPPLevelCount
global function GRXOffer_ContainsBattlePassLevel
global function GRXOffer_ContainsStackablesOnly
global function GRXOffer_ContainsPack
global function GRXOffer_ContainsOnlyPacks
global function GRXOffer_ContainsOnlySinglePack
global function GRXOffer_ContainsApexPack
global function GRXOffer_ContainsSirngePack
global function GRXOffer_ContainsEventPack
global function GRXOffer_ContainsThematicPack
global function GRXOffer_ContainsEventThematicPack
global function GRXOffer_GetSpecialPackName
global function GRXOffer_GetSpecialPackContainsStickers
global function GRXOffer_GetSpecialPackContainsSkydives
global function GRXOffer_GetSpecialPackContainsHolosprays
global function GRXOffer_GetSpecialPackCountShownOnMOTD
global function GRXOffer_GetBundleOfferRestrictions
global function GRXOffer_IsHeirloomPack
global function GRXOffer_ContainsBattlePass
global function GRXOffer_ContainsBattlePassPack
global function GRXOffer_ContainsPresaleBattlePass
global function GRXOffer_GetPricesInPriorityOrder
global function GRXOffer_GetPremiumPriceQuantity
global function GRXOffer_GetCraftingPriceQuantity
global function GRXOffer_GetHeirloomPriceQuantity
global function GRXOffer_GetOriginalPremiumPriceQuantity
global function GRX_PurchaseOffer
global function GRX_MakeItemFlavorBagFromPriceArray
global function GRXOffer_GetEventThematicPackCollectionInfo
global function GRXOffer_GetEventThematicPackCollectionInfoFromScriptOffer
global function GRXOffer_ContainsMilestoneEventPack
global function GRXOffer_IsPurchaseWithinThematicPackLimit
global function GRX_IsLocationActive
global function GRX_ScriptOfferFromCraftingOffer
global function GRX_GetPostGameRewards
global function GRX_MarkRewardAcknowledged
global function GRX_IsLegendOffer

#if DEV
global function PrintSortedStoreSectionData
global function DEV_TestUpdateSmartMerchandisingData
global function DEV_PrintSmartMerchandisingData
#endif
global function SortStoreSectionData
global function GetSortedStoreSectionData
global function GetMostRecentlySeenSection
global function HasSectionBeenSeen
global function GetHighestPageForSection
global function GetCurrentEventSectionName
global function SectionShouldBeMarkedAsNew
global function ServerCallback_UpdatePlayerLastLoggedInTimestamp
global function SetHighestPageSeenForSection
global function SetLastSectionVisited
global function ClearHighestPageSeenForSection
global function UpdateSmartMerchandisingData

global function GRX_QueuedOperationMayDirtyOffers
global function GRX_GetScriptOfferFromOfferAlias



global function GRXCurrency_GetPlayerBalance
global function QueueGRXOperation
global function IsGRXOperationDone
global function ItemFlavorIsStackable
global function GRX_IsOfferRestrictedByOfferAttributes
global function GRX_GetPackFlavOfType
global function Escrow_IsPlayerTrusted_Internal
























global function GRX_GetAllPackFlavors
global function GRX_GetPackCounts
global function GRX_GetTotalPackCount
global function GRX_GetLocationOffers
global function GRX_GetItemDedicatedStoreOffers
global function GRX_EventHasSinglePackOffers
global function GRX_EventHasMultiPackOffers
global function GRX_EventHasCraftingOffers
global function GRX_GetStoreOfferColumn
global function GRX_GetStoreOfferColumnNumRows
global function GRX_GetStoreOffers
global function GRX_GetStoreOfferItems
global function GRX_GetLocationOfferItems
global function GRX_AreOffersReady
global function GRX_AreOffersDirty
global function GRX_GetItemPurchasabilityInfo
global function GRX_IsItemCraftable
global function GRX_CanAfford
global function GRX_CanAffordDelta
global function GRX_GetMaxCanAfford
global function GRX_GetCurrencyArrayFromBag
global function GRX_GetFormattedPrice
global function GRX_GetPriceDisplayData
global function GRX_IsCraftingPrice
global function GRX_IsPremiumPrice
global function GRX_GetNextCurrencyExpirationAmt
global function GRX_GetNextCurrencyExpirationTime
global function GRX_GetGiftingLimitResetDate
global function GetFormattedValueForCurrency
global function AddCallbackAndCallNow_OnGRXInventoryStateChanged
global function AddCallback_OnGRXInventoryStateChanged
global function RemoveCallback_OnGRXInventoryStateChanged
global function AddCallbackAndCallNow_OnGRXOffersRefreshed
global function AddCallback_OnGRXOffersRefreshed
global function RemoveCallback_OnGRXOffersRefreshed
global function AddCallbackAndCallNow_OnGRXAccountAttributesUpdated
global function AddCallback_OnGRXAccountAttributesUpdated
global function RemoveCallback_OnGRXAccountAttributesUpdated
global function AddCallback_OnEntitlementPurchased
global function RemoveCallback_OnEntitlementPurchased
global function SortStoreOfferItems
global function SortOffersBySlot
global function ShowGRXErrorDialogue
global function DEV_GRX_DescribeOffer
global function GRX_IsBadLuckProtectionActive
global function GRXPack_GetOpenButtonIcon
global function GRX_InitScriptOfferFromStoreOffer
global function GRX_AreStoreSectionsEnabled
global function GRX_SetOfferRefreshSuppressed
global function GRX_MarkContainerAsSeen









global function UICodeCallback_GRXSmartMerchandisingDataUpdated

global function HasEscrowBalance
global function Escrow_IsPlayerTrusted
global function GetNextMilestoneRewardPack
global function UpdateOpenedMilestonePackCounts



global function GRX_GetGiftingLimitCounter



global function GRX_GetMostRecentPackOpeningResults
global function GRXPack_GetCustomColor
global function GRXPack_GetCustomCountTextCol


#if DEV









global function DEV_GRX_PrintStoreOfferLocations
global function DEV_GRX_PrintNextCurrencyExpirationInfo
global function DEV_GRX_TestOpenPack
global function DEV_GRX_TestPurchase
global function DEV_GRX_PreviewStoreItem
global function DEV_GRX_PrintContainers

#endif


















global function ServerToUI_PROTO_YouAreGreenLightedForGRX
global function ServerToUI_GRX_QueuedRewardsGiven
global function DisplayQueuedRewardsGiven
global function UICodeCallback_GRXOffersRefreshed
global function UICodeCallback_GRXOffersRefreshedIncremental
global function UICodeCallback_GRXUserInfoUpdated
global function UICodeCallback_GRXAccountAttributesUpdated
global function UICodeCallback_GRXQueryCompleted
global function UICodeCallback_GRXGetOfferCompleted
global function UICodeCallback_GRXCheckForGiftsCompleted
global function UICodeCallback_EntitlementPurchased
global function ShGRX_UIScriptResetComplete
global function ClientToUI_WORKAROUND_GRXPackOpened_Start
global function ClientToUI_WORKAROUND_GRXPackOpened_Entry
global function ClientToUI_WORKAROUND_GRXPackOpened_Finish


global const int MAX_REWARDS_PER_REWARD_SEQ_CALL = 255

global const int QUEUED_REWARDS_MAX_COUNT = 12
const int QUEUED_REWARDS_MAX_ITEMS_COUNT = 1




const int GRX_SCRIPT_QUERY_IDENTIFIER_START_INDEX = INT_MIN


const string SHOP_TAB_ALIAS = "shop"
const string TRUSTED_OVERRIDE_ACCOUNT_ATTRIBUTE_NAME = "trusted"








global enum eItemFlavorGRXMode
{
	NONE = GRX_ITEMFLAVORMODE_NONE,
	REGULAR = GRX_ITEMFLAVORMODE_REGULAR,
	PACK = GRX_ITEMFLAVORMODE_PACK,
	CONSUMABLE = GRX_ITEMFLAVORMODE_CONSUMABLE,
	CURRENCY = GRX_ITEMFLAVORMODE_CURRENCY,
	OWNERSHIP_TARGET = -1337,
	MULTIPLE_OWNERSHIP_TARGET = -9001,
}




global enum eStoreLocation
{
	SHOP,
	SPECIALS,
	SEASONAL,
	_COUNT
}

















global enum eStoreSections
{
	Event
	Personalized
	Flex1
	Flex2
	Flex3
	Featured
	Monthly
	Recolor
	Exotic
	BattlepasShop
	_COUNT
}

global enum eMythicSections
{
	HEIRLOOMS
	PRESTIGE_SKINS
	ARTIFACTS
	UNIVERSALS
	_COUNT
}



const int LIVE_STORE_START_DATE_UNIX_TIMESTAMP = 1722963600

const table< string, array<string> > EventSectionNameToDateMap = {
	
	[ "#FIFTH_ANNIVERSARY_COLLECTION_EVENT" ] = ["2024-02-13 10:00:00 -08:00", "2024-02-27 10:00:00 -08:00"],
	[ "#INNER_BEAST_COLLECTION_EVENT" ] = ["2024-03-05 10:00:00 -08:00", "2024-03-19 10:00:00 -07:00"],
	[ "#NOIR_MOBSTERS_MILESTONE_EVENT" ] = ["2024-03-26 10:00:00 -07:00", "2024-04-16 10:00:00 -07:00"],
	[ "#URBAN_ASSAULT_COLLECTION_EVENT" ] = ["2024-04-23 10:00:00 -07:00", "2024-05-07 10:00:00 -07:00"],
	
	[ "#VOID_RAIDER" ] = ["2024-05-07 10:00:00 -07:00", "2024-05-28 10:00:00 -07:00"],
	
	[ "#DOUBLE_TAKE_COLLECTION_EVENT" ] = ["2024-06-25 10:00:00 -07:00", "2024-07-09 10:00:00 -07:00"],
	[ "#VOID_RECKONING_EVENT" ] = ["2024-07-23 10:00:00 -07:00", "2024-08-06 10:00:00 -07:00"],
	
	[ "#S22CE01_INFO_TITLE" ] = ["2024-08-13 10:00:00 -07:00", "2024-08-27 10:00:00 -07:00"],
	[ "#BLOOD_MOON_PACK_SALE" ] = ["2024-09-03 10:00:00 -07:00", "2024-09-17 10:00:00 -07:00"],
}

const table< string, array<string> > Flex1SectionNameToDateMap = {
	
	[ "#VALENTINES_DAY" ] = ["2024-02-13 10:00:00 -08:00", "2024-02-20 10:00:00 -08:00"],
	[ "#SUN_WARRIOR_STORE" ] = ["2024-04-02 10:00:00 -07:00", "2024-04-09 10:00:00 -07:00"],
	[ "#GOLDEN_WEEK_SALE" ] = ["2024-04-30 10:00:00 -07:00", "2024-05-07 10:00:00 -07:00"],
	
	[ "#DEVIOUS_TRICKSTERS_STORE" ] = ["2024-05-07 10:00:00 -07:00", "2024-06-04 10:00:00 -07:00"],
	[ "#GALACTIC_SPORTS_STORE" ] = ["2024-06-11 10:00:00 -07:00", "2024-06-25 10:00:00 -07:00"],
	
	[ "#VOID_RECKONING_STORE" ] = ["2024-07-23 10:00:00 -07:00", "2024-08-06 10:00:00 -07:00"],
	
	[ "#NEON_OMEN_STORE" ] = ["2024-08-06 10:00:00 -07:00", "2024-08-20 10:00:00 -07:00"],
	[ "#BLOOD_MOON_SALE" ] = ["2024-09-03 10:00:00 -07:00", "2024-09-17 10:00:00 -07:00"],
}

const table<string, array<string> > Flex2SectionNameToDateMap = {
	
	[ "#FOURTH_ANNIVERSARY_SQUADS" ] = ["2024-02-13 10:00:00 -08:00", "2024-02-27 10:00:00 -08:00"],
	[ "#STEELED_DEMON_STORE" ] = ["2024-02-27 10:00:00 -08:00", "2024-03-12 10:00:00 -07:00"],
	[ "#MOLTEN_MAYHEM_PACK_SALE" ] = ["2024-03-19 10:00:00 -07:00", "2024-03-26 10:00:00 -07:00"],
	[ "#POLY_PROWLER_STORE" ] = ["2024-04-09 10:00:00 -07:00", "2024-04-23 10:00:00 -07:00"],
	[ "#GOLDEN_WEEK_ORIGINALS" ] = ["2024-04-30 10:00:00 -07:00", "2024-05-07 10:00:00 -07:00"],
	
	[ "#OFF_DUTY_STORE" ] = ["2024-05-28 10:00:00 -07:00", "2024-06-11 10:00:00 -07:00"],
	
	[ "#BATTLE_ACADEMY_PACK_SALE" ] = ["2024-08-20 10:00:00 -07:00", "2024-09-17 10:00:00 -07:00"],
}

const table<string, array<string> > Flex3SectionNameToDateMap = {
	
	[ "#THIRD_ANNIVERSARY_SQUADS" ] = ["2024-02-13 10:00:00 -08:00", "2024-02-27 10:00:00 -08:00"],
	[ "#MOLTEN_MAYHEM_STORE" ] = ["2024-03-19 10:00:00 -07:00", "2024-03-26 10:00:00 -07:00"],
	[ "#VIVID_NIGHTS_STORE" ] = ["2024-04-16 10:00:00 -07:00", "2024-04-30 10:00:00 -07:00"],
	
	[ "#NITRIDE_WEAPON_ARSENAL" ] = ["2024-05-21 10:00:00 -07:00", "2024-06-04 10:00:00 -07:00"],
	
	[ "#CORRUPTED_SUMMER_STORE" ] = ["2024-07-09 10:00:00 -07:00", "2024-07-23 10:00:00 -07:00"],
	
	[ "#BATTLE_ACADEMY_SALE" ] = ["2024-08-20 10:00:00 -07:00", "2024-09-17 10:00:00 -07:00"],
}


































global struct GRXScriptOffer
{
	array<ItemFlavorBag>  prices
	ItemFlavorBag&        output
	table<string, string> attributes
	array<GRXStoreOfferItem> items

	ItemFlavor ornull     prereq

	bool isCraftingOffer = false

	string               titleText = "Offer Title"
	string               descText = "Description of offer"
	string               offerAlias = ""
	string               prereqText = ""
	asset                image = $""
	string               imageRef = ""
	string				 binkRef = ""
	string               tagText = ""
	string               seasonTag = ""
	string               tooltipTitle = ""
	string               tooltipDesc = ""
	ItemFlavorBag ornull originalPrice = null
	int                  offerType = GRX_OFFERTYPE_DEFAULT
	int                  purchaseLimit = 0
	int					 displayPriority = 0
	int                  expireTime = 0

	bool   isAvailable = true
	string unavailableReason = "#UNAVAILABLE"
	bool   isSKUOffer = false 
	bool isGiftable = false
	bool isStoreV2Offer = false

	int	ineligibilityCode = 0
	array<string> priceAliases
	int purchaseCount = 0

	
	
}

global struct GRXScriptCraftingOffer
{
	ItemFlavor& flavor
	int         craftingPrice
	bool        isAvailable = true
}

	global struct GiftingFriend
	{
		EadpPeopleData& eadpData
		string activeNucleusPersonaId
		EadpPresenceData& activePresence
	}



global struct StoreSectionInfo
{
	
	int sectionId
	string sectionName = ""
	int markedAsNewDate = 0
	array<GRXScriptOffer> offers
}



global struct PurchaseDialogDeepLinkConfig
{
	string ornull 		message = null
	string ornull		priceText = null
	void functionref()	onPurchaseCallback = null
}



global struct PurchaseDialogConfig
{
	
	ItemFlavor ornull     flav = null
	GRXScriptOffer ornull offer = null
	
	GiftingFriend ornull friend = null
	bool isGiftPack = false 
	bool isEventShopDialog = false 
	
	CupEntry ornull entry = null
	bool isCupsReRoll = false
	
	int           quantity = 1
	bool          markAsNew = true
	string ornull messageOverride = null
	string ornull purchaseSoundOverride = null
	string ornull purchaseOptionsMessage = null
	PurchaseDialogDeepLinkConfig ornull deepLinkConfig = null

	void functionref()                     onPurchaseStartCallback = null
	void functionref( bool wasSuccessful ) onPurchaseResultCallback = null
}




global struct ItemFlavorPurchasabilityInfo
{
	bool                                  isPurchasableAtAll = false
	GRXScriptCraftingOffer ornull         craftingOfferOrNull = null
	table<string, array<GRXScriptOffer> > locationToDedicatedStoreOffersMap
}



global struct PriceDisplayData
{
	asset  symbol
	string amount
}


Assert( GRX_CURRENCY_COUNT == 7 )
global ItemFlavor&[GRX_CURRENCY_COUNT] GRX_CURRENCIES = [{...}, {...}, {...}, {...}, {...}, {...}, {...}]

global int GRX_DEV_ITEM = -1
global int GRX_QA_ITEM = -1



















































global struct GRX_PackCollectionInfo
{
	int numCollected = 0
	int numTotalInCollection = 0
}








global enum eScriptGRXOperationStatus
{
	INVALID,
	QUEUED,
	RUNNING,
	DONE_INTERRUPTED,
	DONE_SUCCESS,
	DONE_FAILED,
}


global struct ScriptGRXOperationInfo
{
	int id = -1
	int expectedQueryGoal = -1



		bool shouldRetryOnInterrupt = true

	bool _isAutoOperation = false 

	void functionref( int id )             doOperationFunc
	void functionref( int status )         onDoneCallback

	int    status = eScriptGRXOperationStatus.INVALID
	int    _codeQueryState = -1
	string DEV_culprit = ""
	string DEV_goalInfo = ""
	float  DEV_queueTime = 0.0
}




struct PlayerGRXScriptState

{








		bool isInventoryReady
		bool isInventoryValidated = false
		bool hasInventoryEverBeenClean = false
		int  marketplaceEdition = -1
		bool isOfferRestricted = false



		int          inventoryState = GRX_INVENTORYSTATE_UNINITIALIZED
		array<int>   balances
		array<GRXUserInfoBalances> currencies

		int                           nextScriptQueryId = GRX_SCRIPT_QUERY_IDENTIFIER_START_INDEX
		array<ScriptGRXOperationInfo> operationQueue
		ScriptGRXOperationInfo ornull activeOperationOrNull = null

		bool isAutoOperationQueued = false

		GRXUserInfo& WORKAROUND_lastCodeUserInfo






			bool areOffersReady
			bool areOffersDirty
			int giftingLimitResetDate = 0

			array< GRXContainerInfo > containers



			int giftingLimitCounter = -1


}




struct FileStruct_LifetimeVM
{
	
	int                       WORKAROUND_delayedOffersState
	array< GRXCraftingOffer > WORKAROUND_delayedCraftingOffers
	array< GRXStoreOffer >    WORKAROUND_delayedStoreOffers

	bool WORKAROUND_wasUserInfoUpdatedBeforeLevelInit = false

	
	int mainMilestonePacksOpenedThisClientSession = 0

#if DEV
		string grxStorePreviewItem = ""
#endif
}
FileStruct_LifetimeVM& fileVM



struct SmartMerchData
{
	array<int> highestPagesSeen
	int lastSectionVisited
}




struct FileStruct_LifetimeLevel
{
	array<ItemFlavor>      	packFlavorList
	table<string, int> 	   	currencyIndexMap
	table<int, ItemFlavor> 	grxIndexItemFlavorMap
	table<string, int>     	grxRefToGRXIndexMap

	array<ItemFlavor> stickerPacksWithRewards
	table< int, int > multiOwnershipUnlockMap

#if DEV
		table<string, ItemFlavor> grxRefItemFlavorMap
#endif






		PlayerGRXScriptState localGRXState

		ItemFlavorBag ornull mostRecentPackOpeningResultsOrNull = null


			bool WORKAROUND_isInLifetime = false

			bool PROTO_serverHasGivenGreenLightForUIGRX = false

			array<void functionref()> onGRXInventoryStateChangedCallbacks
			array<void functionref()> onGRXOffersRefreshedCallbacks
			array<void functionref()> onGRXAccountAttributesUpdatedCallbacks
			array<void functionref( int )> onEntitlementPurchasedCallbacks

			table<ItemFlavor, ItemFlavorPurchasabilityInfo> itemFlavorPurchasabilityInfoMap

			table<string, GRXScriptOffer> offerAliasToOfferMap

			table<string, array<GRXScriptOffer> > locationOffersMap

			array<array<array<GRXScriptOffer> > > storeOfferColumns

			array<array<array<GRXScriptOffer> > > specialsStoreOfferColumns

			array<array<array<GRXScriptOffer> > > seasonalStoreOfferColumns


			int lastLoggedInTimestamp = 0
			table<int, StoreSectionInfo > storeSectionInfoMap
			SmartMerchData& smartMerchData







			bool HACK_allowOneBadQueryCompleteCallBecauseOfUIScriptReset = false



	bool GRX_DEBUG_PRINTS_disableTemporarily = false
}
FileStruct_LifetimeLevel& fileLevel


const float USERINFO_DIRTY_DEBOUNCE_DURATION = 0.3


global enum eIneligibilityCode
{
	ELIGIBLE = 0,
	UNKNOWN = 1,

	PURCHASE_CONDITIONS = 100,
	PURCHASE_LIMIT = 101,
	BUNDLE_ITEMS_OWNED = 102,
	CONTENTS_NOT_GRANTABLE = 103
}








void function ShGRX_LevelInit()
{
	FileStruct_LifetimeLevel newFileLevel

		newFileLevel.WORKAROUND_isInLifetime = true

	fileLevel = newFileLevel


		SetDefaultSmartMerchData()


	AddCallback_RegisterRootItemFlavors( void function() {
		Assert( GRX_CURRENCY_COUNT == 7 )
		GRX_CURRENCIES[GRX_CURRENCY_PREMIUM] = expect ItemFlavor(RegisterItemFlavorFromSettingsAsset( $"settings/itemflav/grx_currency/premium.rpak" )) 
		GRX_CURRENCIES[GRX_CURRENCY_CREDITS] = expect ItemFlavor(RegisterItemFlavorFromSettingsAsset( $"settings/itemflav/grx_currency/credits.rpak" )) 
		GRX_CURRENCIES[GRX_CURRENCY_CRAFTING] = expect ItemFlavor(RegisterItemFlavorFromSettingsAsset( $"settings/itemflav/grx_currency/crafting.rpak" )) 
		GRX_CURRENCIES[GRX_CURRENCY_HEIRLOOM] = expect ItemFlavor(RegisterItemFlavorFromSettingsAsset( $"settings/itemflav/grx_currency/heirloom.rpak" )) 
		GRX_CURRENCIES[GRX_CURRENCY_EXOTIC] = expect ItemFlavor(RegisterItemFlavorFromSettingsAsset( $"settings/itemflav/grx_currency/exotic.rpak" )) 
		GRX_CURRENCIES[GRX_CURRENCY_ESCROW] = expect ItemFlavor(RegisterItemFlavorFromSettingsAsset( $"settings/itemflav/grx_currency/escrow.rpak" )) 

		
		GRX_CURRENCIES[GRX_CURRENCY_EVENT] = expect ItemFlavor(RegisterItemFlavorFromSettingsAsset( $"settings/itemflav/grx_currency/s19me01_coin.rpak" )) 

		foreach ( int currencyIndex, ItemFlavor flav in GRX_CURRENCIES )
		{
			fileLevel.currencyIndexMap[ItemFlavor_GetGUIDString( flav )] <- currencyIndex





		}

		foreach ( asset packAsset in GetBaseItemFlavorsFromArray( "packs" ) )
		{
			ItemFlavor ornull flavOrNull = RegisterItemFlavorFromSettingsAsset( packAsset )
			if ( flavOrNull != null )
				fileLevel.packFlavorList.append( expect ItemFlavor(flavOrNull) )
		}

		foreach ( asset currencyBundleAsset in GetBaseItemFlavorsFromArray( "currencyBundles" ) )
			RegisterItemFlavorFromSettingsAsset( currencyBundleAsset )

		foreach ( asset accountFlagAsset in GetBaseItemFlavorsFromArray( "accountFlags" ) )
		{
			ItemFlavor ornull flagFlav = RegisterItemFlavorFromSettingsAsset( accountFlagAsset )









		}
	} )
	AddCallback_OnItemFlavorRegistered( eItemType.account_currency_bundle, AssertCurrencyBundlePlaylistVarsAreValid )

	AddCallback_OnItemFlavorRegistered( eItemType.account_pack, RegisterStickerPacksWithRewards )

	AddCallbackOrMaybeCallNow_OnAllItemFlavorsRegistered( OnAllItemFlavorsRegistered )

		AddCallback_OnGRXInventoryStateChanged( SortAllScriptOffers )


	RegisterSignal( "ScriptGRXOperationDone" )

















		if ( !CanRunClientScript() )
			return

		PlayerGRXScriptState scriptState = GetPlayerGRXScriptState( GetLocalClientPlayer() )
		RunClientScript( "UIToClient_GRXInventoryCleanStateChange", scriptState.isInventoryReady, scriptState.WORKAROUND_lastCodeUserInfo.marketplaceEdition, scriptState.WORKAROUND_lastCodeUserInfo.isOfferRestricted )

		if ( fileVM.WORKAROUND_wasUserInfoUpdatedBeforeLevelInit )
		{
			fileVM.WORKAROUND_wasUserInfoUpdatedBeforeLevelInit = false
			void functionref() whatTheFunc = (void function() {
				wait 1.0
				UICodeCallback_GRXUserInfoUpdated( GRX_GetUserInfo() )
			})
			thread whatTheFunc()
		}


	GRX_DEV_ITEM = GRX_RegisterItem( "account_flag_dev", eItemFlavorGRXMode.REGULAR )
	GRX_QA_ITEM = GRX_RegisterItem( "account_flag_QA", eItemFlavorGRXMode.REGULAR )







}




void function ShGRX_LevelShutdown()
{
	FileStruct_LifetimeLevel newFileLevel
	fileLevel = newFileLevel

	fileLevel.WORKAROUND_isInLifetime = false

	fileVM.WORKAROUND_delayedOffersState = GRX_OFFERSSTATE_UNINITIALIZED
	fileVM.WORKAROUND_delayedCraftingOffers = []
	fileVM.WORKAROUND_delayedStoreOffers = []

	UpdatePlayerGRXScriptState( GetLocalClientPlayer(), null )
}




void function ShGRX_RegisterItemFlavor( ItemFlavor flavor )
{
	string grxModeStr = GetGlobalSettingsString( ItemFlavor_GetAsset( flavor ), "grxMode" )
	Assert( grxModeStr in eItemFlavorGRXMode, "Unknown item flavor GRX mode: " + grxModeStr )
	flavor.grxMode = eItemFlavorGRXMode[grxModeStr]
	if ( flavor.grxMode == eItemFlavorGRXMode.REGULAR
	|| flavor.grxMode == eItemFlavorGRXMode.CONSUMABLE
	|| flavor.grxMode == eItemFlavorGRXMode.PACK
	|| flavor.grxMode == eItemFlavorGRXMode.CURRENCY )
	{
		string grxRef = ItemFlavor_GetGRXAlias( flavor )
		Assert( grxRef != "", "Item " + string(ItemFlavor_GetAsset( flavor )) + " has GRX mode enabled but GRX ref is undefined." )

		flavor.grxIndex = GRX_RegisterItem( grxRef, flavor.grxMode )

		fileLevel.grxIndexItemFlavorMap[flavor.grxIndex] <- flavor
		fileLevel.grxRefToGRXIndexMap[grxRef] <- flavor.grxIndex
#if DEV
			bool duplicateGRXRefFound = grxRef in fileLevel.grxRefItemFlavorMap
			Assert( !duplicateGRXRefFound, "Duplicate GRX ref found. Already used by " + string(ItemFlavor_GetAsset( fileLevel.grxRefItemFlavorMap[grxRef] )) )
			fileLevel.grxRefItemFlavorMap[grxRef] <- flavor
#endif
	}
	else if ( flavor.grxMode == eItemFlavorGRXMode.OWNERSHIP_TARGET )
	{
		ItemFlavor ornull ownershipTarget = ItemFlavor_GetGRXOwnershipTarget( flavor )
		if ( ownershipTarget != null )
		{
			expect ItemFlavor(ownershipTarget)
			if ( ownershipTarget.grxOwnershipTargettedBy == null )
				ownershipTarget.grxOwnershipTargettedBy = []
			array<int> targettedBy = expect array<int>(ownershipTarget.grxOwnershipTargettedBy)
			targettedBy.append( flavor.guid )
		}
	}
	else if ( flavor.grxMode == eItemFlavorGRXMode.MULTIPLE_OWNERSHIP_TARGET )
	{
		array< ItemFlavor > ownershipRequirementsList = ItemFlavor_GetGRXMultipleOwnershipRequirementsList( flavor )
		if ( ownershipRequirementsList.len() == 0 )
		{
			Assert( false, "Item had GRX mode MULTIPLE_OWNERSHIP_TARGET but list was empty: " + string( ItemFlavor_GetAsset( flavor ) ) )
			return
		}

		foreach ( reqFlav in ownershipRequirementsList )
		{
#if DEV
				bool duplicateGRXRefFoundInMultiple = reqFlav.guid in fileLevel.multiOwnershipUnlockMap
				Assert( !duplicateGRXRefFoundInMultiple, "Duplicate GRX ref in multiple unlock mapping found. Already used by " + string( ItemFlavor_GetAsset( GetItemFlavorByGUID( fileLevel.multiOwnershipUnlockMap[ reqFlav.guid ] ) ) ) )
#endif

			fileLevel.multiOwnershipUnlockMap[ reqFlav.guid ] <- flavor.guid
		}
	}


		ItemFlavorPurchasabilityInfo ifpi
		fileLevel.itemFlavorPurchasabilityInfoMap[flavor] <- ifpi

}





void function OnAllItemFlavorsRegistered()
{
}










bool function IsValidItemFlavorGRXIndex( int index, int validationBehavior = eValidation.DONT_ASSERT )
{
	bool good = (index in fileLevel.grxIndexItemFlavorMap)

	if ( !good && validationBehavior == eValidation.ASSERT ) 
	{
		foreach ( int grxIndex, ItemFlavor flav in fileLevel.grxIndexItemFlavorMap )
		{
			GRX_Warning( "##### R5DEV-47389: %d = %s", grxIndex, string(ItemFlavor_GetAsset( flav )) )
		}
	}

	Assert( good || validationBehavior != eValidation.ASSERT, "Unknown item flavor GRX index: " + index + " (valid range is 0-" + (fileLevel.grxIndexItemFlavorMap.len() - 1) + ")" )
	return good
}




int function GetGRXIndexByGRXRef( string grxRef )
{
	return fileLevel.grxRefToGRXIndexMap[ grxRef ]
}




ItemFlavor function GetItemFlavorByGRXIndex( int index )
{
	IsValidItemFlavorGRXIndex( index, eValidation.ASSERT )

	return fileLevel.grxIndexItemFlavorMap[ index ]
}



#if DEV
ItemFlavor function DEV_GetItemFlavorByGRXRef( string grxRef )
{
	return fileLevel.grxRefItemFlavorMap[ grxRef ]
}
#endif

#if DEV
bool function DEV_IsValidGRXRef( string grxRef )
{
	return (grxRef in fileLevel.grxRefItemFlavorMap)
}
#endif



int function ItemFlavor_GetGRXMode( ItemFlavor flavor )
{
	Assert( IsItemFlavorStructValid( flavor.guid, eValidation.ASSERT ) )

	return flavor.grxMode
}




int function ItemFlavor_GetGRXIndex( ItemFlavor flavor, int validationBehavior = eValidation.ASSERT )
{
	Assert( IsItemFlavorStructValid( flavor.guid, eValidation.ASSERT ) )
	Assert( flavor.grxMode != eItemFlavorGRXMode.NONE || validationBehavior == eValidation.DONT_ASSERT, "Attempted to get the GRX index of a non-GRX item flavor: " + DEV_DescItemFlavor( flavor ) )
	Assert( flavor.grxIndex >= 0 || validationBehavior == eValidation.DONT_ASSERT, format( "%s( %s ) has an invalid index (%d)", FUNC_NAME(), DEV_DescItemFlavor( flavor ), flavor.grxIndex ) )
	return flavor.grxIndex
}




string function ItemFlavor_GetGRXAlias( ItemFlavor flavor )
{
	Assert( IsItemFlavorStructValid( flavor.guid, eValidation.ASSERT ) )
	Assert( flavor.grxMode != eItemFlavorGRXMode.NONE, "Attempted to get the GRX alias of a non-GRX item flavor: " + DEV_DescItemFlavor( flavor ) )

	return GetGlobalSettingsString( ItemFlavor_GetAsset( flavor ), "grxRef" )
}




ItemFlavor ornull function ItemFlavor_GetGRXOwnershipTarget( ItemFlavor flavor )
{
	Assert( IsItemFlavorStructValid( flavor.guid, eValidation.ASSERT ) )
	if ( flavor.grxMode != eItemFlavorGRXMode.OWNERSHIP_TARGET )
		return null

	asset ownershipTargetFlavAsset = GetGlobalSettingsAsset( ItemFlavor_GetAsset( flavor ), "ownershipTarget" )
	if ( IsValidItemFlavorSettingsAsset( ownershipTargetFlavAsset ) )
		return GetItemFlavorByAsset( ownershipTargetFlavAsset )
	return null
}



array< ItemFlavor > function ItemFlavor_GetGRXMultipleOwnershipRequirementsList( ItemFlavor flavor )
{
	Assert( IsItemFlavorStructValid( flavor.guid, eValidation.ASSERT ) )
	Assert( flavor.grxMode == eItemFlavorGRXMode.MULTIPLE_OWNERSHIP_TARGET, "attempted to check GRX multiple ownership mode for an item that does not have that mode set: " + string( ItemFlavor_GetAsset( flavor ) ) )

	array< ItemFlavor > ownershipList = []
	foreach ( int index, var ownershipBlock in IterateSettingsAssetArray( ItemFlavor_GetAsset( flavor ), "multipleOwnershipTargets" ) )
	{
		asset ownershipAsset = GetSettingsBlockAsset( ownershipBlock, "multipleOwnershipTarget" )
		Assert( IsValidItemFlavorSettingsAsset( ownershipAsset ), format( "Bad ownership target in GRX configuration of %s: %s", string( ItemFlavor_GetAsset( flavor ) ), string( ownershipAsset ) ) )
		ownershipList.append( GetItemFlavorByAsset( ownershipAsset ) )
	}

	Assert( ownershipList.len() > 0, "Mode was set to MULTIPLE_OWNERSHIP_TARGET, but no valid targets were found: " + string( ItemFlavor_GetAsset( flavor ) ) )
	return ownershipList
}



ItemFlavor ornull function ItemFlavor_GetGRXMultipleOwnershipTarget( ItemFlavor flavor )
{
	Assert( IsItemFlavorStructValid( flavor.guid, eValidation.ASSERT ) )

	if ( flavor.guid in fileLevel.multiOwnershipUnlockMap )
	{
		ItemFlavor target = GetItemFlavorByGUID( fileLevel.multiOwnershipUnlockMap[ flavor.guid ] )
		return target
	}

	return null
}



array<ItemFlavor> function ItemFlavor_GetGRXOwnershipTargettedBy( ItemFlavor flavor )
{
	array<ItemFlavor> out = []
	if ( flavor.grxOwnershipTargettedBy != null )
	{
		foreach ( int targeterGuid in expect array<int>(flavor.grxOwnershipTargettedBy) )
		{
			out.append( GetItemFlavorByGUID( targeterGuid ) )
		}
	}
	return out
}



void function GRXCurrency_RegisterNewCurrencyAssetInEventSlot( ItemFlavor newCurrencyFlav )
{
	Assert( ItemFlavor_GetType( newCurrencyFlav ) == eItemType.account_currency )
	ItemFlavor oldCurrencyFlav = GRX_CURRENCIES [ GRX_CURRENCY_EVENT ]
	GRX_CURRENCIES[ GRX_CURRENCY_EVENT ] = newCurrencyFlav

	int targetIndex = GRXCurrency_GetCurrencyIndex( oldCurrencyFlav )
	delete fileLevel.currencyIndexMap[ ItemFlavor_GetGUIDString( oldCurrencyFlav ) ]
	fileLevel.currencyIndexMap[ ItemFlavor_GetGUIDString( newCurrencyFlav ) ] <- targetIndex








}




int function GRXCurrency_GetCurrencyIndex( ItemFlavor flav )
{
	Assert( ItemFlavor_GetType( flav ) == eItemType.account_currency )
	return fileLevel.currencyIndexMap[ItemFlavor_GetGUIDString( flav )]
}




string function GRXCurrency_GetPurchaseSound( ItemFlavor flav )
{
	Assert( ItemFlavor_GetType( flav ) == eItemType.account_currency )
	return GetGlobalSettingsString( ItemFlavor_GetAsset( flav ), "purchaseSound" )
}




asset function GRXCurrency_GetPreviewModel( ItemFlavor flav )
{
	Assert( ItemFlavor_GetType( flav ) == eItemType.account_currency )
	return GetGlobalSettingsAsset( ItemFlavor_GetAsset( flav ), "previewMdl" )
}




asset function GRXCurrency_GetRewardIcon( ItemFlavor flav )
{
	Assert( ItemFlavor_GetType( flav ) == eItemType.account_currency )
	return GetGlobalSettingsAsset( ItemFlavor_GetAsset( flav ), "rewardIcon" )
}




ItemFlavor function GRXCurrencyBundle_GetCurrencyFlav( ItemFlavor flav )
{
	Assert( ItemFlavor_GetType( flav ) == eItemType.account_currency_bundle )
	return GetItemFlavorByAsset( GetGlobalSettingsAsset( ItemFlavor_GetAsset( flav ), "currencyFlav" ) )
}




int function GRXCurrencyBundle_GetValue( ItemFlavor flav )
{
	Assert( ItemFlavor_GetType( flav ) == eItemType.account_currency_bundle )
	return GetCurrentPlaylistVarInt( "grx_" + ItemFlavor_GetGRXAlias( flav ) + "_count", -1 )
}



asset function AccountFlag_GetPreviewModel( ItemFlavor flav )
{
	Assert( ItemFlavor_GetType( flav ) == eItemType.account_flag )
	return GetGlobalSettingsAsset( ItemFlavor_GetAsset( flav ), "previewMdl" )
}




asset function AccountFlag_GetRewardIcon( ItemFlavor flav )
{
	Assert( ItemFlavor_GetType( flav ) == eItemType.account_flag )
	return GetGlobalSettingsAsset( ItemFlavor_GetAsset( flav ), "rewardIcon" )
}




bool function GRX_IsInventoryReady( entity player = null )
{



		player = GetLocalClientPlayer()

	return GetPlayerGRXScriptState( player ).isInventoryReady
}

















bool function GRX_HasInventoryEverBeenReady( entity player = null )
{






		if ( player == null )
			player = GetLocalClientPlayer()


	PlayerGRXScriptState scriptState = GetPlayerGRXScriptState( player )
	return scriptState.hasInventoryEverBeenClean
}




int function GRX_GetPlayerEdition( entity player = null )
{






		if ( player == null )
			player = GetLocalClientPlayer()


	return GetPlayerGRXScriptState( player ).marketplaceEdition
}




int function GRX_GetNumberOfOwnedItemsByPlayer( array<ItemFlavor> items, entity player = null )
{
	if ( !GetPlayerGRXScriptState( player ).isInventoryReady )
		return 0
	int count = 0
	foreach( item in items )
	{
		if ( GRX_IsItemOwnedByPlayer( item, player ) )
		{
			count++
		}
	}
	return count
}

bool function GRX_IsItemOwnedByPlayer( ItemFlavor flav, entity player = null )
{
	Assert( GetPlayerGRXScriptState( player ).isInventoryReady, "Called GRX_IsItemOwnedByPlayer while the player's inventory was not ready" )

	return IsItemOwnedByPlayerInternal( flav, player )
}

bool function GRX_IsItemOwnedByPlayer_AllowOutOfDateData( ItemFlavor flav, entity player = null )
{
	
	
	
	
	
	

	return IsItemOwnedByPlayerInternal( flav, player )
}
bool function IsItemOwnedByPlayerInternal( ItemFlavor flav, entity player = null )
{
#if DEV
		
		if ( ItemFlavor_GetType( flav ) == eItemType.character )
		{
			var stackInfos = getstackinfos( 3 ) 
			if ( stackInfos != null )
			{
				expect table(stackInfos)
				string funcName = expect string(stackInfos.func)
				const array< string > FUNCS_THAT_CAN_CHECK_CHARACTER_OWNERSHIP_DIRECTLY = [
					"Loadout_IsCharacterUnlockedForPlayer"
					"Loadout_IsCharacterStillPurchasableByPlayer", 
					"PurchaseDialog", 
					"GRXOffer_IsFullyClaimed", 
					"Loadout_IsCharacterOwnedByPlayerIngoringUnlockSources", 
				]
				Assert( FUNCS_THAT_CAN_CHECK_CHARACTER_OWNERSHIP_DIRECTLY.contains( funcName ) )
			}
		}
#endif








		if ( player == null )
			player = GetLocalClientPlayer()


	if ( ItemFlavor_GetPlaylistAvailability( flav ) == eItemFlavorPlaylistAvailability.FORCE_UNLOCK_FOR_SPECIAL_EVENT )
		return true

	int grxMode = ItemFlavor_GetGRXMode( flav )

	if ( grxMode == eItemFlavorGRXMode.OWNERSHIP_TARGET )
	{
		ItemFlavor ornull ownershipTargetOverride = ItemFlavor_GetGRXOwnershipTarget( flav )
		if ( ownershipTargetOverride != null )
			return IsItemOwnedByPlayerInternal( expect ItemFlavor(ownershipTargetOverride), player )

		GRX_Warning( "Item flavor %s is set to use GRX ownership of another item but it isn't a valid item: %s", string(ItemFlavor_GetAsset( flav )), string(GetGlobalSettingsAsset( ItemFlavor_GetAsset( flav ), "ownershipTarget" )) )
		return false
	}

	if ( grxMode == eItemFlavorGRXMode.MULTIPLE_OWNERSHIP_TARGET )
	{
		array< ItemFlavor > ownershipTargetList = ItemFlavor_GetGRXMultipleOwnershipRequirementsList( flav )
		if ( ownershipTargetList.len() == 0 )
		{
			GRX_Warning( "Item flavor %s is set to use GRX ownership of a set of items, but the set was empty: %s", string( ItemFlavor_GetAsset( flav ) ) )
			return false
		}

		foreach ( ItemFlavor ownershipFlav in ownershipTargetList )
		{
			if ( !IsItemOwnedByPlayerInternal( ownershipFlav, player ) )
			{
				return false
			}
		}

		return true
	}

	
	
	
	

	
	


		
		
		
		if ( grxMode == eItemFlavorGRXMode.REGULAR && IsLobby() && GetConVarBool( "mtx_allow_pending_grants_for_item_ownership" ) )
		{
			for ( int index = 0; index < QUEUED_REWARDS_MAX_COUNT; index++ )
			{
				SettingsAssetGUID rewardGUID = player.GetPersistentVarAsInt( format( "grxQueuedRewards[%d].rewardGUIDs[0]", index ) )
				if ( rewardGUID == 0 || !IsValidItemFlavorGUID( rewardGUID ) )
				{
					continue
				}

				ItemFlavor rewardFlav = GetItemFlavorByGUID( rewardGUID )
				if ( flav.guid == rewardFlav.guid )
				{
					GRX_Info( "reporting queued GRX reward as owned instead of relying on GRX_Inventory call or persistence cache --- this should be temporary and should resolve on next successful GRX refresh" )
					return true
				}
			}
		}


	
	if ( ItemFlavor_HasUnlockFunc( flav ) && grxMode == GRX_ITEMFLAVORMODE_NONE )
		return ItemFlavor_PassesUnlockFunc( flav, player )

	if( ItemFlavor_HasExclusiveFunc( flav ) )
	{
		return ItemFlavor_PassesExclusiveFunc( flav, player )
	}

	if ( grxMode == GRX_ITEMFLAVORMODE_NONE )
		return true

	Assert( grxMode == GRX_ITEMFLAVORMODE_REGULAR, format( "Tried to call GRX_IsItemOwnedByPlayer on a non-regular GRX item: %s", string(ItemFlavor_GetAsset( flav )) ) )

	bool has
	if ( !GRX_HasInventoryEverBeenReady( player ) )
	{














		has = true
	}
	else
	{






				Assert( player == GetLocalClientPlayer() )

			has = GRX_HasItem( flav.grxIndex )

	}

	if ( IsEverythingUnlocked() )
		return true

	return has
}



bool function GRXOffer_ContainsMilestoneEventPack( GRXScriptOffer offerData )
{
	if ( offerData.output.flavors.len() == 1 &&
		ItemFlavor_GetType( offerData.output.flavors[0] ) == eItemType.account_pack &&
		ItemFlavor_GetAccountPackType( offerData.output.flavors[0] ) == eAccountPackType.SIRNGE
	)
	{
		return true
	}
	return false
}



bool function GRXOffer_IsPurchaseWithinThematicPackLimit( GRXScriptOffer offerData )
{
	bool withinLimit = true

	GRX_PackCollectionInfo packCollectionInfo = GRXOffer_GetEventThematicPackCollectionInfoFromScriptOffer( offerData )
	if ( packCollectionInfo.numTotalInCollection > 0 )
	{
		withinLimit = offerData.output.quantities[0] <= ( packCollectionInfo.numTotalInCollection - packCollectionInfo.numCollected )
	}

	return withinLimit
}



GRX_PackCollectionInfo function GRXOffer_GetEventThematicPackCollectionInfoFromScriptOffer( GRXScriptOffer offerData )
{
	GRX_PackCollectionInfo packCollectionInfo
	if ( offerData.output.flavors.len() == 1 && ItemFlavor_GetType( offerData.output.flavors[0] ) == eItemType.account_pack )
	{
		
		packCollectionInfo = GRXOffer_GetEventThematicPackCollectionInfo( offerData.output.flavors[0] )

		
		if ( packCollectionInfo.numCollected > packCollectionInfo.numTotalInCollection )
			packCollectionInfo.numCollected = packCollectionInfo.numTotalInCollection
	}

	return packCollectionInfo
}



GRX_PackCollectionInfo function GRXOffer_GetEventThematicPackCollectionInfo( ItemFlavor flav )
{
	Assert( ItemFlavor_GetType( flav ) == eItemType.account_pack, "Tried to get Pack Info on an ItemFlavor that was NOT of type 'account_pack'" )

	GRX_PackCollectionInfo data
	if ( ItemFlavor_GetAccountPackType( flav ) != eAccountPackType.EVENT_THEMATIC )
		return data

	array<ItemFlavor> packContents = GRXPack_GetPackContents( flav )
	Assert( packContents.len() > 0 )
	int numOwned = 0
	foreach ( packContent in packContents )
	{
		if ( GRX_IsItemOwnedByPlayer_AllowOutOfDateData( packContent, GetLocalClientPlayer() ) )
			++numOwned
	}

	int ownedPackCount = GRX_GetPackCount( ItemFlavor_GetGRXIndex( flav ) )
	numOwned += ownedPackCount

	data.numCollected = numOwned
	data.numTotalInCollection = packContents.len()
	return data
}

bool function GRXOffer_IsValid( GRXScriptOffer offer )
{
	return offer.prices.len() > 0
}

bool function GRXOffer_IsActiveForStoreLocation( GRXScriptOffer offer )
{
	return GRXOffer_IsValid( offer ) && offer.expireTime > GetUnixTimestamp()
}


bool function GRXOffer_IsFullyClaimed( GRXScriptOffer offer )
{
	if( GRXOffer_GetBundleOfferRestrictions( offer ) != "" )
		return true

	foreach ( int outputIdx, ItemFlavor outputFlav in offer.output.flavors )
	{
		if ( ItemFlavor_GetGRXMode( outputFlav ) == eItemFlavorGRXMode.REGULAR )
		{
			if ( !GRX_IsItemOwnedByPlayer( outputFlav ) )
				return false
		}
		else if ( ItemFlavor_GetType( outputFlav ) == eItemType.account_pack )
		{
			GRX_PackCollectionInfo packCollectionInfo = GRXOffer_GetEventThematicPackCollectionInfo( outputFlav )
			if ( packCollectionInfo.numTotalInCollection > 0 )
			{
				if ( packCollectionInfo.numCollected < packCollectionInfo.numTotalInCollection )
					return false
			}
			else
			{
				return false 
			}
		}
		else
		{

					
			return false
		}
	}
	return true
}

bool function GRXOffer_IsPurchaseLimitReached( GRXScriptOffer offer )
{
	return offer.purchaseLimit > 0 && offer.purchaseCount >= offer.purchaseLimit
}

bool function GRXOffer_IsEligibleForPurchase( GRXScriptOffer scriptOffer )
{
	return scriptOffer.ineligibilityCode == 0
}



bool function GRXOffer_IsOfferOnlyGiftable( GRXScriptOffer scriptOffer )
{
	foreach ( ItemFlavorBag price in scriptOffer.prices )
	{
		ItemFlavor flavor = price.flavors[0]
		if ( flavor == GRX_CURRENCIES[GRX_CURRENCY_PREMIUM] )
		{
			return price.quantities[0] == 0
		}
	}
	return false
}

int function GRXOffer_RemainingOfferPurchaseCount( GRXScriptOffer offer )
{
	
	if ( offer.purchaseLimit == 0 )
	{
		return OFFER_HAS_NO_LIMIT
	}

	int remainingPurchases = offer.purchaseLimit - offer.purchaseCount
	Assert( remainingPurchases >= 0, FUNC_NAME() + ": " + offer.offerAlias + " reports negative purchases remaining and is not unlimited." )

	return remainingPurchases
}




int function GRXOffer_GetActiveBPPLevelCount( GRXScriptOffer offer )
{
	int activeBPLevels = 0

	foreach ( GRXStoreOfferItem item in offer.items )
	{
		ItemFlavor flav = GetItemFlavorByGRXIndex( item.itemIdx )

		
		if ( ItemFlavor_GetType( flav ) == eItemType.battlepass_purchased_xp )
		{
			
			if ( flav == BattlePass_GetXPPurchaseFlav( expect ItemFlavor( GetActiveBattlePass() ) ) )
			{
				activeBPLevels += item.itemQuantity
			}
		}
	}

	return activeBPLevels
}



bool function GRXOffer_ContainsBattlePassLevel( GRXScriptOffer offer )
{
	foreach ( GRXStoreOfferItem item in offer.items )
	{
		ItemFlavor flav = GetItemFlavorByGRXIndex( item.itemIdx )

		if ( ItemFlavor_GetType( flav ) == eItemType.battlepass_purchased_xp )
		{
			return true
		}
	}

	return false
}



int function GRXOffer_GetOwnedItemsCount( GRXScriptOffer offer )
{
	int count = 0
	foreach ( ItemFlavor outputFlav in offer.output.flavors )
	{
		if ( ItemFlavor_GetGRXMode( outputFlav ) == eItemFlavorGRXMode.REGULAR )
		{
			if ( GRX_IsItemOwnedByPlayer( outputFlav ) )
				count = count + 1
		}
	}
	return count
}




bool function GRXOffer_IsHeirloomPack( GRXScriptOffer offer  )
{
	foreach ( ItemFlavor outputFlav in offer.output.flavors )
	{
		if ( !ItemFlavor_HasQuality( outputFlav ) )
			return false

		if ( ItemFlavor_GetQuality( outputFlav ) != eRarityTier.MYTHIC )
			return false

		if ( Artifacts_IsItemFlavorArtifact( outputFlav ) )
			return false
	}

	return true
}

bool function GRXOffer_ContainsBattlePass( GRXScriptOffer offer  )
{
	foreach ( ItemFlavor outputFlav in offer.output.flavors )
	{
		var itemFlavorType = ItemFlavor_GetType( outputFlav )
		if ( itemFlavorType == eItemType.battlepass_presale_voucher || itemFlavorType == eItemType.battlepass)
			return true
	}

	return false
}

bool function GRXOffer_ContainsBattlePassPack( GRXScriptOffer offer )
{
	ItemFlavor ornull activeBattlePass = GetActiveBattlePass()

	if ( activeBattlePass == null )
		return false

	expect ItemFlavor( activeBattlePass )

	ItemFlavor basic = BattlePass_GetBasicPurchasePack( activeBattlePass )
	ItemFlavor bundle = BattlePass_GetBundlePurchasePack( activeBattlePass )

	foreach ( ItemFlavor outputFlav in offer.output.flavors )
	{
		if ( basic.guid == outputFlav.guid )
		{
			return true
		}

		if ( bundle.guid == outputFlav.guid )
		{
			return true
		}
	}

	return false
}

bool function GRXOffer_ContainsPresaleBattlePass( GRXScriptOffer offer  )
{
	foreach ( ItemFlavor outputFlav in offer.output.flavors )
	{
		if ( ItemFlavor_GetType( outputFlav ) == eItemType.battlepass_presale_voucher )
			return true
	}

	return false
}

array<ItemFlavorBag> function GRXOffer_GetPricesInPriorityOrder( GRXScriptOffer offer )
{
	array<ItemFlavorBag> priceList = clone offer.prices
	priceList.sort( int function( ItemFlavorBag a, ItemFlavorBag b ) {
		if ( GetCurrencyPriority( a.flavors[0] ) < GetCurrencyPriority( b.flavors[0] ) )
			return -1
		else if ( GetCurrencyPriority( a.flavors[0] ) > GetCurrencyPriority( b.flavors[0] ) )
			return 1
		return 0
	} )

	return priceList
}

int function GetCurrencyPriority(ItemFlavor itemFlavor)
{
	int currencyPriority = -1
	switch ( itemFlavor )
	{
		case GRX_CURRENCIES[GRX_CURRENCY_PREMIUM]:
			currencyPriority = GRX_CURRENCY_PREMIUM
			break

		case GRX_CURRENCIES[GRX_CURRENCY_CREDITS]:
			currencyPriority = GRX_CURRENCY_CREDITS
			break

		case GRX_CURRENCIES[GRX_CURRENCY_CRAFTING]:
			currencyPriority = GRX_CURRENCY_CRAFTING
			break

		case GRX_CURRENCIES[GRX_CURRENCY_EVENT]:
			currencyPriority = GRX_CURRENCY_EVENT
			break

		case GRX_CURRENCIES[GRX_CURRENCY_HEIRLOOM]:
			currencyPriority = GRX_CURRENCY_HEIRLOOM
			break

		default:
			Assert( false, "itemFlavor guid: " + itemFlavor.guid + " does not have a currency")
			break
	}

	return currencyPriority
}

int function GRXOffer_GetPremiumPriceQuantity( GRXScriptOffer offer )
{
	foreach ( ItemFlavorBag price in offer.prices )
	{
		if ( price.flavors[0] == GRX_CURRENCIES[GRX_CURRENCY_PREMIUM] )
		{
			return price.quantities[0]
		}
	}
	return 0
}

int function GRXOffer_GetCraftingPriceQuantity( GRXScriptOffer offer )
{
	foreach ( ItemFlavorBag price in offer.prices )
	{
		if ( price.flavors[0] == GRX_CURRENCIES[GRX_CURRENCY_CRAFTING] )
		{
			return price.quantities[0]
		}
	}
	return -1
}

int function GRXOffer_GetHeirloomPriceQuantity( GRXScriptOffer offer )
{
	foreach ( ItemFlavorBag price in offer.prices )
	{
		if ( price.flavors[0] == GRX_CURRENCIES[GRX_CURRENCY_HEIRLOOM] )
		{
			return price.quantities[0]
		}
	}
	return 0
}

int function GRXOffer_GetOriginalPremiumPriceQuantity( GRXScriptOffer offer )
{
	if ( offer.originalPrice == null )	
	{
		return 0
	}

	ItemFlavorBag bag = expect ItemFlavorBag( offer.originalPrice )
#if DEV
		Assert( bag.flavors.len() > 0, "No Flavor was found for the original price of offer." )
#endif
	if ( bag.flavors.len() < 1 )
	{
		return 0
	}

	if ( bag.flavors[0] == GRX_CURRENCIES[GRX_CURRENCY_PREMIUM] )
	{
		return bag.quantities[0]
	}
	return 0
}

bool function GRXOffer_ContainsStackablesOnly( GRXScriptOffer offer )
{
	foreach ( ItemFlavor itemFlavor in offer.output.flavors )
	{
		if ( !ItemFlavorIsStackable( itemFlavor ) )
		{
			return false
		}
	}

	return true
}

bool function GRXOffer_ContainsPack( GRXScriptOffer offer )
{
	foreach ( ItemFlavor outputFlav in offer.output.flavors )
		if ( ItemFlavor_GetGRXMode( outputFlav ) == eItemFlavorGRXMode.PACK && !ItemFlavor_IsBattlepass( outputFlav ) )
		{
			
			
			if ( !ItemFlavor_HasQuality( outputFlav ) || ItemFlavor_GetQuality( outputFlav ) != eRarityTier.MYTHIC )
				return true
		}

	return false
}


bool function GRXOffer_ContainsOnlyPacks( GRXScriptOffer offer )
{
	foreach ( ItemFlavor outputFlav in offer.output.flavors )
	{
		if ( ItemFlavor_GetGRXMode( outputFlav ) != eItemFlavorGRXMode.PACK )
			return false
	}
	return true
}


bool function GRXOffer_ContainsOnlySinglePack( GRXScriptOffer offer )
{
	if ( offer.items.len() != 1 )
		return false

	foreach ( ItemFlavor outputFlav in offer.output.flavors )
	{
		if ( ItemFlavor_GetGRXMode( outputFlav ) != eItemFlavorGRXMode.PACK )
			return false
	}
	return true
}



bool function GRXOffer_ContainsApexPack( GRXScriptOffer offer )
{
	foreach ( ItemFlavor outputFlav in offer.output.flavors )
	{
		if ( ItemFlavor_GetGRXMode( outputFlav ) == eItemFlavorGRXMode.PACK && ItemFlavor_GetAccountPackType( outputFlav ) == eAccountPackType.APEX )
			return true
	}

	return false
}



bool function GRXOffer_ContainsSirngePack( GRXScriptOffer offer )
{
	foreach ( ItemFlavor outputFlav in offer.output.flavors )
	{
		if ( ItemFlavor_GetGRXMode( outputFlav ) == eItemFlavorGRXMode.PACK && ItemFlavor_GetAccountPackType( outputFlav ) == eAccountPackType.SIRNGE )
		{
			return true
		}
	}

	return false
}



bool function GRXOffer_ContainsEventPack( GRXScriptOffer offer )
{
	foreach ( ItemFlavor outputFlav in offer.output.flavors )
	{
		if ( ItemFlavor_GetGRXMode( outputFlav ) == eItemFlavorGRXMode.PACK && ItemFlavor_GetAccountPackType( outputFlav ) == eAccountPackType.EVENT )
			return true
	}

	return false
}



bool function GRXOffer_ContainsThematicPack( GRXScriptOffer offer )
{
	foreach ( ItemFlavor outputFlav in offer.output.flavors )
	{
		if ( ItemFlavor_GetGRXMode( outputFlav ) == eItemFlavorGRXMode.PACK && ItemFlavor_GetAccountPackType( outputFlav ) == eAccountPackType.THEMATIC )
			return true
	}

	return false
}



bool function GRXOffer_ContainsEventThematicPack( GRXScriptOffer offer )
{
	foreach ( ItemFlavor outputFlav in offer.output.flavors )
	{
		if ( ItemFlavor_GetGRXMode( outputFlav ) == eItemFlavorGRXMode.PACK && ItemFlavor_GetAccountPackType( outputFlav ) == eAccountPackType.EVENT_THEMATIC )
			return true
	}

	return false
}



string function GRXOffer_GetSpecialPackName( GRXScriptOffer offer )
{
	string specialPackName = ""
	foreach ( ItemFlavor outputFlav in offer.output.flavors )
	{
		if ( ItemFlavor_GetGRXMode( outputFlav ) == eItemFlavorGRXMode.PACK && ItemFlavor_GetAccountPackType( outputFlav ) != eAccountPackType.APEX )
			specialPackName = ItemFlavor_GetShortName( outputFlav )
	}

	return specialPackName
}



bool function GRXOffer_GetSpecialPackContainsStickers( GRXScriptOffer offer )
{
	bool hasStickers = false
	foreach ( ItemFlavor outputFlav in offer.output.flavors )
	{
		if ( ItemFlavor_GetGRXMode( outputFlav ) == eItemFlavorGRXMode.PACK && ItemFlavor_GetAccountPackType( outputFlav ) != eAccountPackType.APEX )
			hasStickers = GetGlobalSettingsBool( ItemFlavor_GetAsset( outputFlav ), "hasStickers" )
	}

	return hasStickers
}



bool function GRXOffer_GetSpecialPackContainsSkydives( GRXScriptOffer offer )
{
	bool hasSkydives = false
	foreach ( ItemFlavor outputFlav in offer.output.flavors )
	{
		if ( ItemFlavor_GetGRXMode( outputFlav ) == eItemFlavorGRXMode.PACK && ItemFlavor_GetAccountPackType( outputFlav ) != eAccountPackType.APEX )
			hasSkydives = GetGlobalSettingsBool( ItemFlavor_GetAsset( outputFlav ), "hasSkydives" )
	}

	return hasSkydives
}



bool function GRXOffer_GetSpecialPackContainsHolosprays( GRXScriptOffer offer )
{
	bool hasHolosprays = false
	foreach ( ItemFlavor flavIterator in offer.output.flavors )
	{
		if ( ItemFlavor_GetGRXMode( flavIterator ) == eItemFlavorGRXMode.PACK && ItemFlavor_GetAccountPackType( flavIterator ) != eAccountPackType.APEX )
		{
			hasHolosprays = GetGlobalSettingsBool( ItemFlavor_GetAsset( flavIterator ), "hasHolosprays" )
		}
	}

	return hasHolosprays
}



bool function GRXOffer_GetSpecialPackCountShownOnMOTD( GRXScriptOffer offer )
{
	bool usesMOTDButtonForCount = false
	foreach ( ItemFlavor outputFlav in offer.output.flavors )
	{
		if ( ItemFlavor_GetGRXMode( outputFlav ) == eItemFlavorGRXMode.PACK && ItemFlavor_GetAccountPackType( outputFlav ) != eAccountPackType.APEX )
			usesMOTDButtonForCount = GetGlobalSettingsBool( ItemFlavor_GetAsset( outputFlav ), "usesMOTDButtonForCount" )
	}

	return usesMOTDButtonForCount
}




string function GRXOffer_GetBundleOfferRestrictions( GRXScriptOffer offer )
{
	if( offer.output.flavors.len() <= 1 )
		return ""

	if ( GRXOffer_IsHeirloomPack( offer ) ) 
		return ""

	if ( offer.isSKUOffer )
		return ""

	
	
	int itemsOwned = 0
	int coreItemCount = 0
	for ( int offerIndex = 0; offerIndex < offer.items.len(); ++offerIndex )
	{
		
		
		if ( offer.offerType != GRX_OFFERTYPE_BUNDLE || offer.items[offerIndex].itemType == GRX_OFFERITEMTYPE_CORE )
		{
			ItemFlavor coreItemFlav = GetItemFlavorByGRXIndex( offer.items[offerIndex].itemIdx )

			
			if( ItemFlavor_GetGRXMode( coreItemFlav ) != eItemFlavorGRXMode.REGULAR )
			{
				Assert( offer.items[offerIndex].itemType != GRX_OFFERITEMTYPE_CORE ) 
				continue
			}

			
			if( GRX_IsItemOwnedByPlayer( coreItemFlav ) )
				itemsOwned++
			coreItemCount++
		}
	}

	bool lockout = false
	if ( offer.offerType == GRX_OFFERTYPE_BUNDLE )
		lockout = coreItemCount == itemsOwned
	else
		lockout = itemsOwned >= 1 

	
	if ( lockout )
	{
		if ( itemsOwned == 1 )
			return "#BUNDLE_BONUS_LOCKED"
		else if ( itemsOwned > 1 )
			return "#BUNDLE_BONUS_LOCKED_PLURAL"
	}

	return ""
}

string function GRXOffer_GetPriceAliasForPrice( GRXScriptOffer offer, ItemFlavorBag price )
{
	for ( int i = 0; i < offer.prices.len(); ++i )
	{
		if ( ItemFlavorBag_HasSameContents( offer.prices[i], price ) )
		{
			return offer.priceAliases[i]
		}
	}

	Assert( false, "Failed to lookup price alias for offer: " + offer.offerAlias )
	return ""
}



bool function GRX_QueuedOperationMayDirtyOffers()
{
	PlayerGRXScriptState scriptState = GetPlayerGRXScriptState( GetLocalClientPlayer() )

	if ( scriptState.operationQueue.len() != 0 )
	{
		foreach ( ScriptGRXOperationInfo info in scriptState.operationQueue )
		{
			switch ( info.expectedQueryGoal )
			{
				case GRX_HTTPQUERYGOAL_CRAFT_ITEM:
				case GRX_HTTPQUERYGOAL_PURCHASE_PACK:
				case GRX_HTTPQUERYGOAL_PURCHASE_CHARACTER:
				case GRX_HTTPQUERYGOAL_PURCHASE_STORE_OFFER:
				case GRX_HTTPQUERYGOAL_PURCHASE_BUNDLE_OFFER:
				case GRX_HTTPQUERYGOAL_GIFT_OFFER:
					return true
			}
		}
	}

	return false
}



void function QueueGRXOperation( entity player, ScriptGRXOperationInfo operationInfo, bool DEV_isDevOperation = false )
{
	Assert( IsLobby() || DEV_isDevOperation, "QueueGRXOperation should only be called when in the lobby." )
	if ( !IsLobby() && !DEV_isDevOperation )
		return

	PlayerGRXScriptState scriptState = GetPlayerGRXScriptState( player )

	QueueGRXOperationInternal( player, operationInfo, scriptState )

	UpdatePlayerGRXScriptState( player, scriptState.WORKAROUND_lastCodeUserInfo )
}













bool function IsGRXOperationDone( ScriptGRXOperationInfo operationInfo )
{
	if ( operationInfo.status == eScriptGRXOperationStatus.DONE_SUCCESS )
		return true

	if ( operationInfo.status == eScriptGRXOperationStatus.DONE_FAILED )
		return true

	if ( operationInfo.status == eScriptGRXOperationStatus.DONE_INTERRUPTED )
		return true

	return false
}




void function QueueGRXOperationInternal( entity player, ScriptGRXOperationInfo operationInfo, PlayerGRXScriptState scriptState )
{

		Assert( scriptState.operationQueue.len() == 0, "Attempted to queue a UI GRX operation while one was already queued." )


	operationInfo.DEV_culprit = FUNC_NAME( 2 )

	operationInfo.DEV_queueTime = UITime()




	operationInfo.status = eScriptGRXOperationStatus.QUEUED
	operationInfo.id = scriptState.nextScriptQueryId
	scriptState.nextScriptQueryId += 1
	if ( operationInfo._isAutoOperation )
	{
		Assert( !scriptState.isAutoOperationQueued )
		scriptState.isAutoOperationQueued = true
		scriptState.operationQueue.insert( 0, operationInfo )
	}
	else
	{
		scriptState.operationQueue.append( operationInfo )
	}
}




int function GRXCurrency_GetPlayerBalance( entity player, ItemFlavor flav )
{
	Assert( ItemFlavor_GetType( flav ) == eItemType.account_currency )

	PlayerGRXScriptState scriptState = GetPlayerGRXScriptState( player )
	Assert( scriptState.isInventoryReady, "Tried to get player currency balance while their GRX inventory state was not ready" )

	if( !scriptState.isInventoryReady || scriptState.currencies.len() == 0 )
		return 0

	int currencyIndex = GRXCurrency_GetCurrencyIndex( flav )
	return scriptState.currencies[currencyIndex].balance
}




void function GRX_WaitXprogressMigrateStatus_GiftOffer( int opId, string offerAlias, int hardwareId, string nucleus_pid, string nucleus_id, array< int > expectedPrice, bool useDiscountedPrice )
{
	while ( CrossProgression_IsRequestingUserMigrateStatus() )
		WaitFrame()

	GRX_GiftOffer( opId, offerAlias, hardwareId, nucleus_pid, nucleus_id, expectedPrice, useDiscountedPrice )
}

void function GRX_PurchaseOffer( int opId, int queryGoal, GRXScriptOffer offer, ItemFlavorBag price, int quantity, GiftingFriend ornull friend )
{
	int craftingItemIdx = GRX_ITEM_INDEX_INVALID;

	if ( friend != null )
	{
		GRX_PurchaseOfferForFriend( expect GiftingFriend( friend ), opId, offer, price )
		return
	}

	string priceAlias

	if ( offer.isCraftingOffer )
	{
		Assert( queryGoal == GRX_HTTPQUERYGOAL_CRAFT_ITEM )
		Assert( quantity == 1 )

		craftingItemIdx = ItemFlavor_GetGRXIndex( offer.output.flavors[0] )
	}
	else
	{
		priceAlias = GRXOffer_GetPriceAliasForPrice( offer, price )
	}

	GRX_PurchaseOfferV2( opId, queryGoal, offer.offerAlias, craftingItemIdx, quantity, priceAlias, GRX_GetCurrencyArrayFromBag( price ) )
}

void function GRX_PurchaseOfferForFriend( GiftingFriend friend, int opId, GRXScriptOffer offer, ItemFlavorBag price )
{
	bool useDiscountedPrice = false
	if ( offer.originalPrice != null ) 
		useDiscountedPrice = true

	GRX_Info( "Gift offer - offer alias = %s, giftee hardware = %i, giftee nuc pid = %s, giftee nuc id = %s", offer.offerAlias, friend.activePresence.hardware, friend.activeNucleusPersonaId, friend.eadpData.eaid )

	
	if ( CrossProgression_QueryUserMigrateStatusIfNeeded( friend.eadpData.eaid ) )
	{
		thread GRX_WaitXprogressMigrateStatus_GiftOffer( opId, offer.offerAlias, friend.activePresence.hardware, friend.activeNucleusPersonaId, friend.eadpData.eaid, GRX_GetCurrencyArrayFromBag( price ), useDiscountedPrice )
		return
	}

	GRX_GiftOffer( opId, offer.offerAlias, friend.activePresence.hardware, friend.activeNucleusPersonaId, friend.eadpData.eaid, GRX_GetCurrencyArrayFromBag( price ), useDiscountedPrice )
}





ItemFlavorBag function GRX_GetMostRecentPackOpeningResults()
{
	Assert( fileLevel.mostRecentPackOpeningResultsOrNull != null, "Tried to call GRX_GetMostRecentPackOpeningResults with no pack opening results available for use" )

	ItemFlavorBag bag = expect ItemFlavorBag(fileLevel.mostRecentPackOpeningResultsOrNull)
	fileLevel.mostRecentPackOpeningResultsOrNull = null
	return bag
}




array<ItemFlavor> function GRX_GetAllPackFlavors()
{
	return fileLevel.packFlavorList
}



ItemFlavor ornull function GRX_GetPackFlavOfType( entity player, int packType )
{
	foreach ( ItemFlavor pack in GetAllItemFlavorsOfType( eItemType.account_pack ) )
	{
		if ( ItemFlavor_GetAccountPackType( pack ) == packType )
		{
			return pack
		}
	}
	return null
}



table<ItemFlavor, int> function GRX_GetPackCounts()
{
	Assert( GetPlayerGRXScriptState( GetLocalClientPlayer() ).isInventoryReady )

	table<ItemFlavor, int> packCountMap = {}

	foreach ( ItemFlavor pack in GRX_GetAllPackFlavors() )
	{
		packCountMap[pack] <- GRX_GetPackCount( ItemFlavor_GetGRXIndex( pack ) )
	}

	return packCountMap
}




int function GRX_GetTotalPackCount()
{
	Assert( GetPlayerGRXScriptState( GetLocalClientPlayer() ).isInventoryReady )

	int count = 0
	foreach ( ItemFlavor pack in GRX_GetAllPackFlavors() )
		count += GRX_GetPackCount( ItemFlavor_GetGRXIndex( pack ) )

	return count
}




















array<GRXScriptOffer> function GRX_GetValidLocationOffers( string location )
{
	array<GRXScriptOffer> validOffers

	if ( location in fileLevel.locationOffersMap )
	{
		validOffers = clone fileLevel.locationOffersMap[location]
	}

	for ( int i = 0; i < validOffers.len();  )
	{
		if ( !GRXOffer_IsValid( validOffers[i] ) )
		{
			validOffers.fastremove( i )
		}
		else
		{
			++i
		}
	}

	return validOffers
}



array<GRXScriptOffer> function GRX_GetLocationOffers( string location )
{
	Assert( GetPlayerGRXScriptState( GetLocalClientPlayer() ).areOffersReady, "Called GRX_GetLocationOffers when offers weren't ready" )

	if ( location in fileLevel.locationOffersMap )
	{
		return GRX_GetValidLocationOffers( location )
	}

	return []
}



bool function GRX_IsLocationActive( string location )
{
	Assert( GetPlayerGRXScriptState( GetLocalClientPlayer() ).areOffersReady, "Called GRX_IsLocationActive when offers weren't ready" )

	if ( location in fileLevel.locationOffersMap )
	{
		return GRX_GetValidLocationOffers( location ).len() > 0
	}

	return false
}



array<GRXScriptOffer> function GRX_GetItemDedicatedStoreOffers( ItemFlavor flav, string location )
{
	ItemFlavorPurchasabilityInfo ifpi = GRX_GetItemPurchasabilityInfo( flav )
	if ( !(location in ifpi.locationToDedicatedStoreOffersMap) )
		return []
	return ifpi.locationToDedicatedStoreOffersMap[location]
}



bool function GRX_EventHasSinglePackOffers( ItemFlavor event )
{
	bool isRestricted = GRX_IsOfferRestricted()
	return GRX_GetItemDedicatedStoreOffers( MilestoneEvent_GetMainPackFlav( event ), MilestoneEvent_GetFrontPageGRXOfferLocation( event, isRestricted ) ).len() > 0
}



bool function GRX_EventHasMultiPackOffers( ItemFlavor event )
{
	bool isRestricted = GRX_IsOfferRestricted()
	return GRX_GetItemDedicatedStoreOffers( MilestoneEvent_GetGuaranteedPackFlav( event ), MilestoneEvent_GetFrontPageGRXOfferLocation( event, isRestricted ) ).len() > 0
}



bool function GRX_EventHasCraftingOffers( ItemFlavor event )
{
	
	Assert( ItemFlavor_GetType( event ) == eItemType.calevent_milestone )

	array<GRXScriptOffer> singlePurchaseOffers = MilestoneEvent_GetSinglePackOffers( event )
	array<GRXScriptOffer> multiplePurchaseOffers = MilestoneEvent_GetMultiPackOffers( event )

	
	if ( singlePurchaseOffers.len() > 0 )
	{
		foreach ( singleOffer in singlePurchaseOffers )
		{
			if ( singleOffer.prices.len() > 0 )
			{
				int craftingPrice = GRXOffer_GetCraftingPriceQuantity( singleOffer )
				if ( craftingPrice >= 0 )
				{
					return true
				}
			}
		}
	}

	
	if ( multiplePurchaseOffers.len() > 0 )
	{
		foreach ( multiOffer in multiplePurchaseOffers )
		{
			if ( multiOffer.prices.len() > 0 )
			{
				int craftingPrice = GRXOffer_GetCraftingPriceQuantity( multiOffer )
				if ( craftingPrice >= 0 )
				{
					return true
				}
			}
		}
	}

	return false
}



int function GRX_GetStoreOfferColumnNumRows( int col, int storeLocation )
{
	Assert( GetPlayerGRXScriptState( GetLocalClientPlayer() ).areOffersReady, "Called GRX_GetStoreOfferColumnNumRows when offers weren't ready" )

	int numRows = 0
	array<array<array<GRXScriptOffer> > > storeOfferColumns

	if( storeLocation == eStoreLocation.SHOP )
		storeOfferColumns = fileLevel.storeOfferColumns
	else if( storeLocation == eStoreLocation.SPECIALS )
		storeOfferColumns = fileLevel.specialsStoreOfferColumns
	else if( storeLocation == eStoreLocation.SEASONAL )
		storeOfferColumns = fileLevel.seasonalStoreOfferColumns
	else
		return 0

	if ( storeOfferColumns.isvalidindex( col ) )
	{
		if ( storeOfferColumns[col].len() > 0 && storeOfferColumns[col][0].len() > 0 )
		{
			foreach ( offer in storeOfferColumns[col][0] )
			{
				if ( !GRXOffer_IsActiveForStoreLocation( offer ) )
				{
					continue
				}

				numRows++
				break
			}
		}

		if ( storeOfferColumns[col].len() > 1 && storeOfferColumns[col][1].len() > 0 )
		{
			foreach ( offer in storeOfferColumns[col][1] )
			{
				if ( !GRXOffer_IsActiveForStoreLocation( offer ) )
				{
					continue
				}

				numRows++
				break
			}
		}
	}

	return numRows
}



array<GRXScriptOffer> function GRX_GetStoreOfferColumn( int col, int row, int storeLocation )
{
	Assert( GetPlayerGRXScriptState( GetLocalClientPlayer() ).areOffersReady, "Called GRX_GetStoreOfferColumn when offers weren't ready" )

	array<GRXScriptOffer> offers
	array<array<array<GRXScriptOffer> > > storeOfferColumns

	if( storeLocation == eStoreLocation.SHOP )
		storeOfferColumns = fileLevel.storeOfferColumns
	else if( storeLocation == eStoreLocation.SPECIALS )
		storeOfferColumns = fileLevel.specialsStoreOfferColumns
	else if( storeLocation == eStoreLocation.SEASONAL )
		storeOfferColumns = fileLevel.seasonalStoreOfferColumns
	else
		return offers

	if ( storeOfferColumns.isvalidindex( col ) )
	{
		if ( storeOfferColumns[col].isvalidindex( row ) && storeOfferColumns[col][row].len() > 0 )
		{
			foreach ( offer in storeOfferColumns[col][row] )
			{
				if ( !GRXOffer_IsActiveForStoreLocation( offer ) )
				{
					continue
				}

				offers.append( offer )
			}
		}
	}

	return offers
}




array<GRXScriptOffer> function GRX_GetStoreOffers( int storeLocation )
{
	Assert( GetPlayerGRXScriptState( GetLocalClientPlayer() ).areOffersReady, "Called GRX_GetStoreOffers when offers weren't ready" )

	array<GRXScriptOffer> offers
	for ( int col = 0; col < 5; col++ ) 
		for ( int row = 0; row < 2; row++ )
			offers.extend( GRX_GetStoreOfferColumn( col, row, storeLocation ) )

	return offers
}




array<ItemFlavor> function GRX_GetStoreOfferItems( int storeLocation )
{
	array<GRXScriptOffer> offers = GRX_GetStoreOffers( storeLocation )
	array<ItemFlavor> items

	foreach ( offer in offers )
		items.append( offer.output.flavors[0] )

	return items
}




array<ItemFlavor> function GRX_GetLocationOfferItems( string location )
{
	array<GRXScriptOffer> offers = GRX_GetLocationOffers( location )
	array<ItemFlavor> items

	foreach ( offer in offers )
		items.append( offer.output.flavors[0] )

	return items
}




bool function GRX_AreOffersReady( bool allowDirty = true )
{
	PlayerGRXScriptState scriptState = GetPlayerGRXScriptState( GetLocalClientPlayer() )

	if ( !allowDirty && GRX_AreOffersDirty() )
	{
		return false
	}

	return scriptState.isInventoryReady && scriptState.areOffersReady
}




bool function GRX_AreOffersDirty()
{
	PlayerGRXScriptState scriptState = GetPlayerGRXScriptState( GetLocalClientPlayer() )
	return scriptState.areOffersDirty || GRX_QueuedOperationMayDirtyOffers()
}




bool function GRX_IsBadLuckProtectionActive()
{
	if ( !GRX_IsInventoryReady() )
		return false

	return false
}




asset function GRXPack_GetOpenButtonIcon( ItemFlavor flav )
{
	Assert( ItemFlavor_GetType( flav ) == eItemType.account_pack )

	return GetGlobalSettingsAsset( ItemFlavor_GetAsset( flav ), "openButtonIcon" )
}




vector ornull function GRXPack_GetCustomColor( ItemFlavor flav, int idx )
{
	Assert( ItemFlavor_GetType( flav ) == eItemType.account_pack )

	if ( !GetGlobalSettingsBool( ItemFlavor_GetAsset( flav ), "useCustomColors" ) )
		return null

	return GetGlobalSettingsVector( ItemFlavor_GetAsset( flav ), format( "customCol%d", idx ) )
}




vector ornull function GRXPack_GetCustomCountTextCol( ItemFlavor flav )
{
	Assert( ItemFlavor_GetType( flav ) == eItemType.account_pack )

	if ( !GetGlobalSettingsBool( ItemFlavor_GetAsset( flav ), "useCustomColors" ) )
		return null

	return GetGlobalSettingsVector( ItemFlavor_GetAsset( flav ), "countTextCol" )
}




bool function GRXPack_IsEphemeral( ItemFlavor flav )
{
	Assert( ItemFlavor_GetType( flav ) == eItemType.account_pack )

	return GetGlobalSettingsBool( ItemFlavor_GetAsset( flav ), "isEphemeral" )
}




bool function GRXPack_IsExpectedToContainSingleItemWithCurrency( ItemFlavor flav )
{
	Assert( ItemFlavor_GetType( flav ) == eItemType.account_pack )

	return GetGlobalSettingsBool( ItemFlavor_GetAsset( flav ), "isExpectedToContainSingleItemWithCurrency" )
}




asset function GRXPack_GetTickModel( ItemFlavor flav )
{
	Assert( ItemFlavor_GetType( flav ) == eItemType.account_pack )

	return GetGlobalSettingsAsset( ItemFlavor_GetAsset( flav ), "tickMdl" )
}




array<ItemFlavor> function GRXPack_GetPackContents( ItemFlavor flav )
{
	Assert( ItemFlavor_GetType( flav ) == eItemType.account_pack )

	array<ItemFlavor> contents = []
	foreach ( var contentsBlock in IterateSettingsAssetArray( ItemFlavor_GetAsset( flav ), "packContents" ) )
	{
		asset contentAsset = GetSettingsBlockAsset( contentsBlock, "flavor" )
		if ( IsValidItemFlavorSettingsAsset( contentAsset ) )
			contents.append( GetItemFlavorByAsset( contentAsset ) )
	}
	return contents
}



asset function GRXPack_GetStickerCompletionRewardPack( ItemFlavor flav )
{
	Assert( ItemFlavor_GetType( flav ) == eItemType.account_pack )
	return GetGlobalSettingsAsset( ItemFlavor_GetAsset( flav ), "stickerRewardPack" )
}

string function GRXPack_GetStickerCompletionRewardSequence( ItemFlavor flav )
{
	Assert( ItemFlavor_GetType( flav ) == eItemType.account_pack )
	return GetGlobalSettingsString( ItemFlavor_GetAsset( flav ), "stickerRewardSequence" )
}





























string function GRXPack_GetTickModelSkin( ItemFlavor flav )
{
	Assert( ItemFlavor_GetType( flav ) == eItemType.account_pack )

	return GetGlobalSettingsString( ItemFlavor_GetAsset( flav ), "tickMdlSkin" )
}

bool function GRXPack_PlayerOwnsAllItemsInPack( entity player, ItemFlavor pack )
{
	
	if ( !IsValid( player ) || !GRX_HasInventoryEverBeenReady( player ) )
	{
		return false
	}

	
	foreach ( grxItem in GRXPack_GetPackContents( pack ) )
	{
		Assert( grxItem.grxMode != eItemFlavorGRXMode.NONE, "GRX mode cannot be none for items inside pack for ownership check." )







		if ( !GRX_HasItem( ItemFlavor_GetGRXIndex( grxItem ) ) )
		{
			return false
		}

	}

	return true
}




ItemFlavorPurchasabilityInfo function GRX_GetItemPurchasabilityInfo( ItemFlavor flavor )
{
	PlayerGRXScriptState scriptState = GetPlayerGRXScriptState( GetLocalClientPlayer() )
	Assert( scriptState.isInventoryReady, "Called ItemFlavor_GetPurchasabilityInfo when the GRX inventory state was not ready" )
	Assert( scriptState.areOffersReady, "Called ItemFlavor_GetPurchasabilityInfo when the GRX offers were not ready" )
	Assert( flavor in fileLevel.itemFlavorPurchasabilityInfoMap, "Called ItemFlavor_GetPurchasabilityInfo when item was not in itemFlavorPurchasabilityInfoMap: " + string(ItemFlavor_GetAsset( flavor )) )

	return fileLevel.itemFlavorPurchasabilityInfoMap[flavor]
}




bool function GRX_IsItemCraftable( ItemFlavor itemFlavor )
{
	ItemFlavorPurchasabilityInfo ifpi = GRX_GetItemPurchasabilityInfo( itemFlavor )
	return (ifpi.craftingOfferOrNull != null)
}




bool function GRX_CanAfford( ItemFlavorBag price, int quantity, bool considerEscrow = false )
{
	entity player = GetLocalClientPlayer()
	PlayerGRXScriptState scriptState = GetPlayerGRXScriptState( player )
	Assert( scriptState.isInventoryReady, "Tried to check is the player can afford something while their GRX inventory state was not ready" )

	ItemFlavor premiumCurrencyFlav = GRX_CURRENCIES[GRX_CURRENCY_PREMIUM]

	foreach ( int costIndex, ItemFlavor costFlav in price.flavors )
	{
		int costQuantity = quantity * price.quantities[costIndex]
		Assert( ItemFlavor_GetType( costFlav ) == eItemType.account_currency, "NYI!" )

		int currencyBalance = GRXCurrency_GetPlayerBalance( player, costFlav )

		if ( costFlav.guid == premiumCurrencyFlav.guid && considerEscrow )
		{
			int escrowBalance = GRXCurrency_GetPlayerBalance( player, GRX_CURRENCIES[GRX_CURRENCY_ESCROW] )
			if ( costQuantity > ( currencyBalance - escrowBalance ) )
				return false
		}
		else
		{
			if ( costQuantity > currencyBalance )
				return false
		}
	}

	return true
}

int function GRX_CanAffordDelta( ItemFlavorBag price, int quantity )
{
	PlayerGRXScriptState scriptState = GetPlayerGRXScriptState( GetLocalClientPlayer() )
	Assert( scriptState.isInventoryReady, "Tried to check is the player can afford something while their GRX inventory state was not ready" )

	foreach ( int costIndex, ItemFlavor costFlav in price.flavors )
	{
		int costQuantity = quantity * price.quantities[costIndex]
		Assert( ItemFlavor_GetType( costFlav ) == eItemType.account_currency, "NYI!" )

		if ( costQuantity > GRXCurrency_GetPlayerBalance( GetLocalClientPlayer(), costFlav ) )
			return costQuantity - GRXCurrency_GetPlayerBalance( GetLocalClientPlayer(), costFlav )
	}

	return 0
}




int function GRX_GetMaxCanAfford( ItemFlavorBag price, int quantity )
{
	PlayerGRXScriptState scriptState = GetPlayerGRXScriptState( GetLocalClientPlayer() )
	Assert( scriptState.isInventoryReady, "Tried to check is the player can afford something while their GRX inventory state was not ready" )

	Assert( GRX_IsPremiumPrice( price ) )
	foreach ( int costIndex, ItemFlavor costFlav in price.flavors )
	{
		Assert( ItemFlavor_GetType( costFlav ) == eItemType.account_currency, "NYI!" )

		int basePrice       = price.quantities[costIndex]
		int currencyBalance = GRXCurrency_GetPlayerBalance( GetLocalClientPlayer(), costFlav )
		int maxAfford       = int( floor( currencyBalance / float( basePrice ) ) )

		return minint( maxAfford, quantity )
	}

	return 0
}



array<int> function GRX_GetCurrencyArrayFromBag( ItemFlavorBag bag )
{
	array<int> priceArray
	priceArray.resize( GRX_CURRENCY_COUNT, -1 )
	foreach ( int costIndex, ItemFlavor costFlav in bag.flavors )
	{
		int costQuantity = bag.quantities[costIndex]
		Assert( ItemFlavor_GetType( costFlav ) == eItemType.account_currency, "NYI!" )

		priceArray[GRXCurrency_GetCurrencyIndex( costFlav )] = costQuantity
	}

	return priceArray
}




string function GRX_GetFormattedPrice( ItemFlavorBag bag, int quantity = 1 )
{
	array<int> priceArray = GRX_GetCurrencyArrayFromBag( bag ) 
	string formattedPrice = ""
	foreach ( currencyIndex, price in priceArray )
	{
		if ( price < 0 )
			continue

		if ( formattedPrice.len() > 0 )
			formattedPrice = formattedPrice + " & "

		ItemFlavor currency = GRX_CURRENCIES[currencyIndex]
		formattedPrice = formattedPrice + "%$" + ItemFlavor_GetIcon( currency ) + "% " + FormatAndLocalizeNumber( "1", float(price * quantity), true )
	}

	return formattedPrice
}





PriceDisplayData function GRX_GetPriceDisplayData( ItemFlavorBag bag, int quantity = 1 )
{
	array<int> priceArray = GRX_GetCurrencyArrayFromBag( bag ) 
	PriceDisplayData data

	foreach ( currencyIndex, price in priceArray )
	{
		if ( price < 0 )
			continue

		Assert( data.amount.len() == 0 )

		data.symbol = ItemFlavor_GetIcon( GRX_CURRENCIES[currencyIndex] )
		data.amount = FormatAndLocalizeNumber( "1", float(price * quantity), true )
	}

	return data
}




bool function GRX_IsCraftingPrice( ItemFlavorBag bag )
{
	return (bag.flavors.len() == 1 && bag.flavors[0] == GRX_CURRENCIES[GRX_CURRENCY_CRAFTING])
}




bool function GRX_IsPremiumPrice( ItemFlavorBag bag )
{
	return (bag.flavors.len() == 1 && bag.flavors[0] == GRX_CURRENCIES[GRX_CURRENCY_PREMIUM])
}




string function GetFormattedValueForCurrency( int value, int currencyIndex )
{
	ItemFlavor currency = GRX_CURRENCIES[currencyIndex]

	return "%$" + ItemFlavor_GetIcon( currency ) + "% " + FormatAndLocalizeNumber( "1", float( value ), true )
}




void function AddCallbackAndCallNow_OnGRXInventoryStateChanged( void functionref() cb, bool HACK_dontErrorOnDuplicate = false )
{
	if ( fileLevel.onGRXInventoryStateChangedCallbacks.contains( cb ) )
	{
		Assert( HACK_dontErrorOnDuplicate, "Tried to add a callback that was already added" )
	}
	fileLevel.onGRXInventoryStateChangedCallbacks.append( cb )

	cb()
}



void function AddCallback_OnGRXInventoryStateChanged( void functionref() cb, bool HACK_dontErrorOnDuplicate = false )
{
	if ( fileLevel.onGRXInventoryStateChangedCallbacks.contains( cb ) )
	{
		Assert( HACK_dontErrorOnDuplicate, "Tried to add a callback that was already added" )
	}
	fileLevel.onGRXInventoryStateChangedCallbacks.append( cb )
}




void function RemoveCallback_OnGRXInventoryStateChanged( void functionref() cb )
{
	Assert( fileLevel.onGRXInventoryStateChangedCallbacks.contains( cb ), "Tried to remove a callback that was not added" )
	fileLevel.onGRXInventoryStateChangedCallbacks.fastremovebyvalue( cb )
}




void function AddCallbackAndCallNow_OnGRXOffersRefreshed( void functionref() cb, bool HACK_dontErrorOnDuplicate = false )
{
	if ( fileLevel.onGRXOffersRefreshedCallbacks.contains( cb ) )
	{
		Assert( HACK_dontErrorOnDuplicate, "Tried to add a callback that was already added" )
		return
	}
	fileLevel.onGRXOffersRefreshedCallbacks.append( cb )

	cb()
}




void function AddCallback_OnGRXOffersRefreshed( void functionref() cb )
{
	Assert( !fileLevel.onGRXOffersRefreshedCallbacks.contains( cb ), "Tried to add a callback that was already added" )
	fileLevel.onGRXOffersRefreshedCallbacks.append( cb )
}




void function RemoveCallback_OnGRXOffersRefreshed( void functionref() cb )
{
	Assert( fileLevel.onGRXOffersRefreshedCallbacks.contains( cb ), "Tried to remove a callback that was not added" )
	fileLevel.onGRXOffersRefreshedCallbacks.fastremovebyvalue( cb )
}



void function AddCallbackAndCallNow_OnGRXAccountAttributesUpdated( void functionref() callback )
{
	AddCallback_OnGRXAccountAttributesUpdated( callback )
	callback()
}



void function AddCallback_OnGRXAccountAttributesUpdated( void functionref() callback )
{
	Assert( !fileLevel.onGRXAccountAttributesUpdatedCallbacks.contains( callback ), "Tried to add a callback that was already added" )
	fileLevel.onGRXAccountAttributesUpdatedCallbacks.append( callback )
}



void function RemoveCallback_OnGRXAccountAttributesUpdated( void functionref() callback )
{
	Assert( fileLevel.onGRXAccountAttributesUpdatedCallbacks.contains( callback ), "Tried to remove a callback that was not added" )
	fileLevel.onGRXAccountAttributesUpdatedCallbacks.fastremovebyvalue( callback )
}




void function AddCallback_OnEntitlementPurchased( void functionref( int ) cb )
{
	if ( fileLevel.onEntitlementPurchasedCallbacks.contains( cb ) )
	{
		Assert( false, "Tried to add a callback that was already added" )
	}
	fileLevel.onEntitlementPurchasedCallbacks.append( cb )
}




void function RemoveCallback_OnEntitlementPurchased( void functionref( int ) cb )
{
	Assert( fileLevel.onEntitlementPurchasedCallbacks.contains( cb ), "Tried to remove a callback that was not added" )
	fileLevel.onEntitlementPurchasedCallbacks.fastremovebyvalue( cb )
}







#if DEV
void function DEV_GRX_PrintStoreOfferLocations()
{
	foreach ( ItemFlavor itemLocation, ItemFlavorPurchasabilityInfo ifpi in fileLevel.itemFlavorPurchasabilityInfoMap )
	{
		if ( ifpi.locationToDedicatedStoreOffersMap.len() == 0 )
			continue

		printf( "%s", string(ItemFlavor_GetAsset( itemLocation )) )
		foreach ( string storeLocation, array< GRXScriptOffer > locationOffers in ifpi.locationToDedicatedStoreOffersMap )
		{
			foreach ( GRXScriptOffer locationOffer in locationOffers )
				printf( "\t[%s] %s", storeLocation, Localize( locationOffer.titleText ) )
		}
	}
}

void function DEV_GRX_PrintNextCurrencyExpirationInfo()
{
	PlayerGRXScriptState grxState = GetPlayerGRXScriptState( GetLocalClientPlayer() )

	foreach ( int idx, GRXUserInfoBalances currency in grxState.currencies )
	{
		if (currency.nextCurrencyExpirationAmt > 0)
		{
			int secondsToExpire = currency.nextCurrencyExpirationTime - GetUnixTimestamp(); 
			float SECPERDAY = 86400.0; 
			float daysToExpire = secondsToExpire / SECPERDAY;
			printt( "Next Currency Expiration Info:", currency.nextCurrencyExpirationAmt, "AC expire in", daysToExpire, "days | expiretime =", currency.nextCurrencyExpirationTime )
		}
	}
}

void function DEV_GRX_TestOpenPack( string ref = "pack_cosmetic_rare" )
{
	ItemFlavor pack = DEV_GetItemFlavorByGRXRef( ref )
	ScriptGRXOperationInfo operation
	operation.expectedQueryGoal = GRX_HTTPQUERYGOAL_OPEN_PACK
	operation.doOperationFunc = (void function( int opID ) : ( pack )
	{
		GRX_OpenPack( opID, ItemFlavor_GetGRXIndex( pack ) )
	})
	operation.onDoneCallback = null
	QueueGRXOperation( GetLocalClientPlayer(), operation, true )
}
#endif


#if DEV
void function DEV_GRX_TestPurchase( string ref = "pack_cosmetic_rare", array<int> price = [1, 0, 0, 0, 0], int qty = 1 )
{
	ItemFlavor flav = DEV_GetItemFlavorByGRXRef( ref )
	ScriptGRXOperationInfo operation
	operation.expectedQueryGoal = GRX_HTTPQUERYGOAL_PURCHASE_PACK
	operation.doOperationFunc = (void function( int opID ) : ( flav, price, qty, ref )
	{
		GRX_PurchaseOfferV2( opID, GRX_HTTPQUERYGOAL_PURCHASE_PACK, "Store_Offer_pack_cosmetic_rare_1", GRX_ITEM_INDEX_INVALID, qty, "price1", price )
	})
	operation.onDoneCallback = null
	QueueGRXOperation( GetLocalClientPlayer(), operation, true )
}
#endif






































































void function GRX_Warning( string fmt, ... )
{
	if ( GetConVarInt( "mtx_debug_level" ) < GRX_DEBUG_LEVEL_WARN )
	{
		return
	}

	table stackInfos = expect table(getstackinfos( 2 ))

	array< var > vargs
	for ( int i = 0; i < vargc; ++i )
	{
		vargs.append( vargv[i] )
	}

	Warning( "[GRX][%s] %s\n", stackInfos.func, vformat( fmt, vargs ) )
}
void function GRX_Info( string fmt, ... )
{
#if DEV
	if ( fileLevel.GRX_DEBUG_PRINTS_disableTemporarily )
	{
		return
	}

	if ( GetConVarInt( "mtx_debug_level" ) < GRX_DEBUG_LEVEL_INFO )
	{
		return
	}

	table stackInfos = expect table(getstackinfos( 2 ))

	array< var > vargs
	for ( int i = 0; i < vargc; ++i )
	{
		vargs.append( vargv[i] )
	}

	printf( "[GRX][%s] %s\n", stackInfos.func, vformat( fmt, vargs ) )
#endif
}

void function GRX_Trace( string fmt, ... )
{
#if DEV
	if ( fileLevel.GRX_DEBUG_PRINTS_disableTemporarily )
	{
		return
	}

	if ( GetConVarInt( "mtx_debug_level" ) < GRX_DEBUG_LEVEL_TRACE )
	{
		return
	}

	table stackInfos = expect table(getstackinfos( 2 ))


	array< var > vargs
	for ( int i = 0; i < vargc; ++i )
	{
		vargs.append( vargv[i] )
	}

	string message = format( "[GRX][%s] %s\n", stackInfos.func, vformat( fmt, vargs ) )
	printf( message )
	SpamLog( message )
#endif
}































































































































































































































































































































































































PlayerGRXScriptState function GetPlayerGRXScriptState( entity player )
{






			Assert( player == GetLocalClientPlayer()
			|| player == null 
			|| GetLocalClientPlayer() == null  )


		return fileLevel.localGRXState

}
















void function UICodeCallback_GRXUserInfoUpdated( GRXUserInfo codeUserInfo )
{
	if ( !fileLevel.WORKAROUND_isInLifetime )
	{
		fileVM.WORKAROUND_wasUserInfoUpdatedBeforeLevelInit = true
		return
	}

	HandleGRXCodeUserInfoUpdated( GetLocalClientPlayer(), codeUserInfo )

	if ( fileVM.WORKAROUND_delayedOffersState != GRX_OFFERSSTATE_UNINITIALIZED )
	{
		HandleGRXOffersRefreshed( fileVM.WORKAROUND_delayedOffersState, fileVM.WORKAROUND_delayedCraftingOffers, fileVM.WORKAROUND_delayedStoreOffers )

		fileVM.WORKAROUND_delayedOffersState = GRX_OFFERSSTATE_UNINITIALIZED
		fileVM.WORKAROUND_delayedCraftingOffers = []
		fileVM.WORKAROUND_delayedStoreOffers = []
	}
}



void function UICodeCallback_GRXAccountAttributesUpdated()
{
	GRX_Info( "numCallbacks: %d", fileLevel.onGRXAccountAttributesUpdatedCallbacks.len() )

	foreach ( void functionref() callback in fileLevel.onGRXAccountAttributesUpdatedCallbacks )
	{
		callback()
	}
}



void function ShGRX_UIScriptResetComplete()
{
	fileLevel.HACK_allowOneBadQueryCompleteCallBecauseOfUIScriptReset = true
	fileLevel.PROTO_serverHasGivenGreenLightForUIGRX = true 

	GRXUserInfo codeUserInfo = GRX_GetUserInfo()
	HandleGRXCodeUserInfoUpdated( GetLocalClientPlayer(), codeUserInfo )
}




void function HandleGRXCodeUserInfoUpdated( entity player, GRXUserInfo codeUserInfo )
{
	GRX_Info( "%s - inventoryState: %s, balances: %s, queryGoal: %d, queryOwner: %s, queryState: %s, querySeqNum: %d",
		string(player),
		string(codeUserInfo.inventoryState) + (codeUserInfo.inventoryState == GRX_INVENTORYSTATE_CLEAN ? "CLEAN" : "NON-CLEAN"),
		codeUserInfo.currencies.join( "," ),
		codeUserInfo.queryGoal,
		string(codeUserInfo.queryOwner) + (codeUserInfo.queryOwner == GRX_HTTPQUERYOWNER_CLIENT ? "CLIENT" : "SERVER"),
		string(codeUserInfo.queryState) + (codeUserInfo.queryState == GRX_HTTPQUERYSTATE_ACTIVE ? "ACTIVE" : "NON-ACTIVE"),
		codeUserInfo.querySeqNum
	)

	UpdatePlayerGRXScriptState( player, codeUserInfo )
}




void function UpdatePlayerGRXScriptState( entity player, GRXUserInfo ornull codeUserInfo = null, bool markInventoryDirty = false )
{
	GRX_Info( "called from %s for %s", FUNC_NAME( 1 ), string(player) )












	if ( codeUserInfo == null ) 
	{



			codeUserInfo = GRX_GetUserInfo()

	}
	expect GRXUserInfo(codeUserInfo)

	PlayerGRXScriptState scriptState = GetPlayerGRXScriptState( player )
	scriptState.WORKAROUND_lastCodeUserInfo = codeUserInfo
	scriptState.marketplaceEdition = codeUserInfo.marketplaceEdition
	scriptState.isOfferRestricted = codeUserInfo.isOfferRestricted

	scriptState.giftingLimitResetDate = codeUserInfo.sparkleLimitResetDate

	scriptState.giftingLimitCounter = codeUserInfo.sparkleLimitCounter

	bool wasConsideringInventoryReady = scriptState.isInventoryReady
	bool willConsiderInventoryReady = false

	
	int targetQueryState = GRX_HTTPQUERYSTATE_NONE

	if ( GetConVarBool( "mtx_inventory_clean_during_transactions_enabled" ) )
	{
		targetQueryState = GRX_HTTPQUERYSTATE_ACTIVE

		if ( markInventoryDirty )
		{
			wasConsideringInventoryReady = false
		}
	}

	if ( codeUserInfo.inventoryState == GRX_INVENTORYSTATE_CLEAN && codeUserInfo.queryState <= targetQueryState )
	{
		willConsiderInventoryReady = true


			if ( !fileLevel.PROTO_serverHasGivenGreenLightForUIGRX || !fileLevel.WORKAROUND_isInLifetime )
				willConsiderInventoryReady = false

	}

	scriptState.inventoryState = codeUserInfo.inventoryState


	if ( fileLevel.WORKAROUND_isInLifetime )
	{
		UpdatePlayerGRXContainers( player, codeUserInfo )
	}


	bool isFirstTimeClean = false
	if ( willConsiderInventoryReady )
	{




			scriptState.isInventoryReady = true
			scriptState.currencies = codeUserInfo.currencies
			UpdateActiveUserInfoPanels()











		if ( scriptState.isInventoryReady && !scriptState.hasInventoryEverBeenClean )
		{
			scriptState.hasInventoryEverBeenClean = true
			isFirstTimeClean = true














		}













		RunGRXOperations( player, scriptState )

		
		if ( !GetConVarBool( "mtx_inventory_clean_during_transactions_enabled" ) )
		{
			if ( scriptState.activeOperationOrNull != null )
			{
				willConsiderInventoryReady = false
			}
		}
	}

	if ( !willConsiderInventoryReady && scriptState.isInventoryReady )
	{
		scriptState.isInventoryReady = false
		scriptState.currencies.clear()
	}





















































		if ( willConsiderInventoryReady != wasConsideringInventoryReady )
		{
			foreach ( void functionref() cb in fileLevel.onGRXInventoryStateChangedCallbacks )
				cb()

			if ( CanRunClientScript() )
				RunClientScript( "UIToClient_GRXInventoryCleanStateChange", scriptState.isInventoryReady, scriptState.WORKAROUND_lastCodeUserInfo.marketplaceEdition, scriptState.WORKAROUND_lastCodeUserInfo.isOfferRestricted )
		}

}



void function UpdatePlayerGRXContainers( entity player, GRXUserInfo codeUserInfo )
{
	if ( !GetConVarBool( "mtx_useClientContainers" ) )
	{
		return
	}

	PlayerGRXScriptState scriptState = GetPlayerGRXScriptState( player )
	scriptState.containers = codeUserInfo.containers

	EadpPeopleList eadFriendlist = EADP_GetFriendsListWithOffline()
	array< GRXContainerInfo > giftingContainers

	foreach ( GRXContainerInfo container in codeUserInfo.containers )
	{
		if ( container.type == GRX_CONTAINERTYPE_GIFT )
		{
			container.senderName = GetFriendNameFromNucleusPId( container.senderNucleusPid, eadFriendlist.people )
			giftingContainers.append( container )
		}

		if ( container.isNew )
		{
			array< ItemFlavor > newItems

			foreach ( int itemIndex in container.itemIndices )
			{
				ItemFlavor itemFlav = GetItemFlavorByGRXIndex( itemIndex )
				Newness_TEMP_MarkItemAsNewAndInformServer( itemFlav )

				GRX_Info( "%s - marking container item %s as new", string( player ), ItemFlavor_GetAssetName( itemFlav ) )
			}
		}
	}

	AddGiftCacheMessages( giftingContainers )
}




























void function ServerToUI_PROTO_YouAreGreenLightedForGRX()
{
	fileLevel.PROTO_serverHasGivenGreenLightForUIGRX = true
	UpdatePlayerGRXScriptState( GetLocalClientPlayer() )
}




void function ServerToUI_GRX_QueuedRewardsGiven()
{
	thread TryRunDialogFlowThread()
}



bool function DisplayQueuedRewardsGiven()
{
	

	entity player = GetLocalClientPlayer()

	if ( !IsLocalClientEHIValid() )
		return false

	for ( int persistentArrayIdx = 0; persistentArrayIdx < QUEUED_REWARDS_MAX_COUNT; persistentArrayIdx++ )
	{
		Assert( QUEUED_REWARDS_MAX_ITEMS_COUNT == 1 )
		SettingsAssetGUID ornull rewardItemFlavGUID = GetQueuedRewardOrNull( persistentArrayIdx )
		if ( rewardItemFlavGUID == null )
			continue

		expect SettingsAssetGUID( rewardItemFlavGUID )
		ItemFlavor rewardItemFlav = GetItemFlavorByGUID( rewardItemFlavGUID )

		Assert( QUEUED_REWARDS_MAX_ITEMS_COUNT == 1 )
		int quantity = expect int(  GetDialogFlowTablesValueOrPersistence( format( "grxQueuedRewards[%d].rewardQuantities[0]", persistentArrayIdx )  ) ) 

		SettingsAssetGUID sourceItemFlavGUID   = expect int( GetDialogFlowTablesValueOrPersistence( format( "grxQueuedRewards[%d].sourceGUID", persistentArrayIdx ) ) ) 
		int sourceItemExtraData                = expect int( GetDialogFlowTablesValueOrPersistence( format( "grxQueuedRewards[%d].sourceGUID_extraData", persistentArrayIdx ) ) ) 
		ItemFlavor ornull sourceItemFlav       = null
		if ( sourceItemFlavGUID != 0 )
		{
			if ( IsValidItemFlavorGUID( sourceItemFlavGUID ) )
				sourceItemFlav = GetItemFlavorByGUID( sourceItemFlavGUID )
			else
				GRX_Warning( "Found unregistered ItemFlavorGUID " + string(sourceItemFlavGUID) + ". This is probably because the source asset has been deleted from Bakery." )
		}

		if ( IsInvalidTypeForRewardCeremony( rewardItemFlav.typeIndex ) )
		{
			GRX_MarkRewardAcknowledged( rewardItemFlavGUID, persistentArrayIdx )
			continue
		}

		string titleText = "#GENERIC_REWARD_RECEIVED"
		string descText  = ""
		string headerText = ""
		bool noShowLow   = false
		if ( sourceItemFlav != null )
		{
			expect ItemFlavor( sourceItemFlav )
			switch( ItemFlavor_GetType( sourceItemFlav ) )
			{
				case eItemType.challenge:
				{
					int tierIdx = sourceItemExtraData

					int tierCount = Challenge_GetTierCount( sourceItemFlav )

					if ( tierCount <= 0 ) 
					{
						descText = ""
					}
					else
					{
						descText = Challenge_GetDescription( sourceItemFlav, tierIdx )
					}

					if ( Challenge_GetTimeSpanKind( sourceItemFlav ) == eChallengeTimeSpanKind.EVENT_SPECIAL_2 )
					{
						titleText = ItemFlavor_GetShortDescription( sourceItemFlav )
						descText = ItemFlavor_GetLongDescription( sourceItemFlav )
					}
					else
					{
						titleText = "#CHALLENGE_COMPLETED_HEADER"
					}
					break
				}

				case eItemType.calevent_collection:
				{
					titleText = ItemFlavor_GetLongName( sourceItemFlav )
					descText = "#LOGIN_REWARD"

					
					if ( ItemFlavor_GetType( rewardItemFlav ) == eItemType.music_pack )
					{
						thread (void function() : (rewardItemFlav) {
							RequestSetItemFlavorLoadoutSlot( WaitForLocalClientEHI(), Loadout_MusicPack(), rewardItemFlav )
						})()
					}

					break
				}

				case eItemType.calevent_login:
				{
					titleText = ItemFlavor_GetLongName( sourceItemFlav )
					descText = ItemFlavor_GetLongDescription( sourceItemFlav )
					break
				}

				case eItemType.quest:
				{
					titleText = ItemFlavor_GetLongName( sourceItemFlav )
					descText = ItemFlavor_GetLongDescription( sourceItemFlav )
					break
				}

				default: Assert( false )
			}
		}
		else
		{
			descText = ItemFlavor_GetLongName( rewardItemFlav )
		}

		int level = -1
		if ( ItemFlavor_GetType( rewardItemFlav ) == eItemType.gladiator_card_badge )
		{
			EHI playerEHI = ToEHI( player )
			level = GetPlayerBadgeDataInteger( playerEHI, rewardItemFlav, 0, null )
#if DEV
				if ( level < 0 )
				{
					printt( "DisplayQueuedRewardsGiven has a badge level < 0", level, ItemFlavor_GetAssetName( rewardItemFlav ) )
				}
#endif
		}

		BattlePassReward rewardInfo
		rewardInfo.level = level
		rewardInfo.flav = rewardItemFlav
		rewardInfo.quantity = quantity
		ShowRewardCeremonyDialog(
			headerText,
			titleText,
			descText,
			[rewardInfo],
			false,
			false,
			noShowLow,
			true )

		GRX_MarkRewardAcknowledged( rewardItemFlavGUID, persistentArrayIdx )
		Newness_TEMP_MarkItemAsNewAndInformServer( rewardItemFlav )

		return true 
	}

	return false
}





















































































void function RunGRXOperations( entity player, PlayerGRXScriptState scriptState )
{
	if ( !scriptState.isInventoryReady )
		return

	if ( scriptState.activeOperationOrNull != null )
		return





	if ( scriptState.operationQueue.len() == 0 )
	{







		return
	}

	ScriptGRXOperationInfo operationInfo = scriptState.operationQueue[0] 
	scriptState.activeOperationOrNull = operationInfo

	operationInfo.status = eScriptGRXOperationStatus.RUNNING


	float time = UITime()



	GRX_Info( "%s - script operation running, culprit: %s, id: %d, age: %d", string( player ), operationInfo.DEV_culprit, operationInfo.id, time - operationInfo.DEV_queueTime )

	
	



	thread WORKAROUND_CallOperationDoFuncOnFrameEnd( operationInfo )
}
void function WORKAROUND_CallOperationDoFuncOnFrameEnd( ScriptGRXOperationInfo operationInfo )
{







	WaitEndFrame()

	if ( operationInfo.status != eScriptGRXOperationStatus.RUNNING )
	{
		GRX_Info( "operationInfo.status (%d) != eScriptGRXOperationStatus.RUNNING", operationInfo.status )
		return
	}




	










	float startTime = UITime()
	while( GRX_GetUserInfo().queryState != GRX_HTTPQUERYSTATE_NONE )
	{
		if ( UITime() - startTime > 5.0 )
		{
			GRX_Info( "while( GRX_GetUserInfo().queryState (%d) != GRX_HTTPQUERYSTATE_NONE ) running for more than 5.0s", GRX_GetUserInfo().queryState )
			startTime = UITime()
		}
		WaitFrame()
	}

	if ( !fileLevel.WORKAROUND_isInLifetime )
	{
		
		return
	}













	operationInfo.doOperationFunc( operationInfo.id )
}




































































































































































void function UICodeCallback_GRXQueryCompleted( int queryScriptId, int queryGoal, int queryState, bool notifyOffersDirty )
{
	HandleGRXQueryCompleted( GetLocalClientPlayer(), queryScriptId, queryGoal, queryState, notifyOffersDirty )
}
















void function HandleGRXQueryCompleted( entity player, int queryScriptId, int queryGoal, int queryState, bool notifyOffersDirty )

{
	GRX_Info( "%s - queryScriptId: %d, queryGoal: %d, queryState: %d", string( player ), queryScriptId, queryGoal, queryState )

	































































		PlayerGRXScriptState scriptState = GetPlayerGRXScriptState( player )


	if ( queryScriptId == -1 || queryScriptId == 0 )
		return 









	if ( queryScriptId > 0 )
		return 



		if ( fileLevel.HACK_allowOneBadQueryCompleteCallBecauseOfUIScriptReset && scriptState.activeOperationOrNull == null )
		{
			fileLevel.HACK_allowOneBadQueryCompleteCallBecauseOfUIScriptReset = false
			return
		}


	Assert( scriptState.activeOperationOrNull != null, "Looks like a GRX query was initiated without using QueueGRXOperation. This is dangerous!" )

	ScriptGRXOperationInfo operationInfo = expect ScriptGRXOperationInfo( scriptState.activeOperationOrNull )

	Assert( operationInfo.id == queryScriptId )

	Assert( queryGoal == operationInfo.expectedQueryGoal ) 

	operationInfo._codeQueryState = queryState

	if ( queryState == GRX_HTTPQUERYSTATE_INTERRUPTED )
	{
		operationInfo.status = eScriptGRXOperationStatus.DONE_INTERRUPTED
	}
	else if ( queryState == GRX_HTTPQUERYSTATE_ERROR )
	{








		operationInfo.status = eScriptGRXOperationStatus.DONE_FAILED
	}
	else
	{
		operationInfo.status = eScriptGRXOperationStatus.DONE_SUCCESS
	}


	GRX_Info( "%s - script operation done, culprit: %s, id: %d, status: %s", string( player ), operationInfo.DEV_culprit, operationInfo.id, GetEnumString( "eScriptGRXOperationStatus", operationInfo.status ) )

	if ( operationInfo.onDoneCallback != null )
		operationInfo.onDoneCallback( operationInfo.status )
	Signal( operationInfo, "ScriptGRXOperationDone" )


		if ( operationInfo.status != eScriptGRXOperationStatus.DONE_SUCCESS )
			ShowGRXErrorDialogue( "" )

		if ( GetConVarBool( "mtx_hardenDirtyOffers" ) && notifyOffersDirty )
		{
			scriptState.areOffersDirty = true
		}


	if ( operationInfo._isAutoOperation )
	{
		Assert( scriptState.isAutoOperationQueued )
		scriptState.isAutoOperationQueued = false
	}
	scriptState.activeOperationOrNull = null
	scriptState.operationQueue.remove( 0 )

	UpdatePlayerGRXScriptState( player, null, true )
}




































































































































































void function UICodeCallback_GRXOffersRefreshed( int offersState, array< GRXCraftingOffer > craftingOffers, array< GRXStoreOffer > storeOffers )
{
	GRX_Info( "offersState: %d, craftingOffers: %d, storeOffers: %d", offersState, craftingOffers.len(), storeOffers.len() )

	if ( fileLevel.WORKAROUND_isInLifetime )
	{
		HandleGRXOffersRefreshed( offersState, craftingOffers, storeOffers )
	}
	else
	{
		fileVM.WORKAROUND_delayedOffersState = offersState
		fileVM.WORKAROUND_delayedCraftingOffers = craftingOffers
		fileVM.WORKAROUND_delayedStoreOffers = storeOffers
	}
}



void function UICodeCallback_GRXOffersRefreshedIncremental( array< GRXStoreOffer > codeOffers )
{
	GRX_Info( "storeOffers: %d", codeOffers.len() )

	foreach ( GRXStoreOffer codeOffer in codeOffers )
	{
		if ( !( codeOffer.offerAlias in fileLevel.offerAliasToOfferMap ) )
		{
			GRX_Warning( "Failed to incrementally update %s, existing offer not found!", codeOffer.offerAlias )
			continue
		}

		GRXScriptOffer existingOffer = fileLevel.offerAliasToOfferMap[codeOffer.offerAlias]

		bool hadValidPrices = GRXOffer_IsValid( existingOffer )

		existingOffer.prices.clear()
		existingOffer.priceAliases.clear()

		array<string> offerProblems = []

		GRX_InitScriptOfferPricesFromStoreOffer( codeOffer, existingOffer, offerProblems )

		if ( offerProblems.len() > 0 )
		{
			GRX_Warning( "Incrementally-updated offer %s has problems: - %s", codeOffer.offerAlias, offerProblems.join( " - " ) )
			return
		}

		bool hasValidPrices = GRXOffer_IsValid( existingOffer )

		if ( hasValidPrices )
		{
			SetOriginalPriceForGRXScriptOffer( existingOffer )
		}

		if ( hasValidPrices != hadValidPrices )
		{
			GRX_InitScriptOfferLocation( existingOffer, true )
		}

		existingOffer.purchaseCount = codeOffer.purchaseCount
		existingOffer.ineligibilityCode = codeOffer.ineligibilityCode
	}

	
	PlayerGRXScriptState scriptState = GetPlayerGRXScriptState( GetLocalClientPlayer() )
	scriptState.areOffersDirty = false

	foreach ( void functionref() cb in fileLevel.onGRXOffersRefreshedCallbacks )
	{
		cb()
	}
}



void function UICodeCallback_GRXGetOfferCompleted( GRXGetOfferInfo getOfferInfo )
{
	GiftingDialog_UpdateEligibilityInformation( getOfferInfo )

#if DEV
		GRX_Info( "GET OFFER COMPLETED" )
		if ( getOfferInfo.isEligible == true )
			GRX_Info("is eligible")
		else
			GRX_Info("not eligible")

		for ( int i = 0; i < getOfferInfo.prices.len(); i++ )
		{
			GRX_Info( "Price set " + i )
			foreach ( price in getOfferInfo.prices[i] )
			{
				GRX_Info( "price = " + price )
			}
		}
#endif
}



void function UICodeCallback_GRXCheckForGiftsCompleted( int batchCounter, int totalNumBatches, GRXScriptInboxMessage inboxMessage )
{
	
	ProcessGiftingInboxMessage( batchCounter, totalNumBatches, inboxMessage )
}



void function UICodeCallback_EntitlementPurchased( int entitlement )
{
	foreach ( void functionref( int ) callback in fileLevel.onEntitlementPurchasedCallbacks )
	{
		callback( entitlement )
	}
}


#if DEV

void function DEV_GRX_PreviewStoreItem( string grxRef )
{
	fileVM.grxStorePreviewItem = grxRef
	thread _Force_Refresh_Offers()
}

void function DEV_GRX_PrintContainers()
{
	PlayerGRXScriptState scriptState = GetPlayerGRXScriptState( GetLocalClientPlayer() )

	printf( "GRX Containers (%d): \n", scriptState.containers.len() )
	foreach ( GRXContainerInfo container in scriptState.containers )
	{
		printf( "Container \"%s\"\n", container.containerId )
		printf( "\tType = %d\n", container.type )
		printf( "\tTimestamp = %d\n", container.timestamp )
		printf( "\tIs New? = %s\n", container.isNew ? "true" : "false" )
		printf( "\tItems = %d\n", container.itemIndices.len() )

		for ( int i = 0; i < container.itemIndices.len(); ++i )
		{
			printf( "\t\tIndex = %d, Count = %d\n", container.itemIndices[i], container.itemCounts[i] )
		}
	}
}

void function _Force_Refresh_Offers()
{
	ClientCommand( "mtx_getOffersInterval 5" )
	wait 6.0
	ClientCommand( "mtx_getOffersInterval 300" )
}


#endif


void function SetOriginalPriceForGRXScriptOffer( GRXScriptOffer scriptOffer )
{
	if ( scriptOffer.prices.len() == 0 )
	{
		return
	}

	if ( scriptOffer.offerType == GRX_OFFERTYPE_BUNDLE )
	{
		scriptOffer.originalPrice = null
		Assert( scriptOffer.prices.len() > 0,
				format( "Cannot set originalPrice for offer %s because it has an empty prices array.", scriptOffer.offerAlias ) )
		if ( scriptOffer.prices.len() > 1 )
		{
			ItemFlavorBag originalPriceBag = scriptOffer.prices[1]
			if( originalPriceBag.flavors.len() > 0 )
			{
				
				
				scriptOffer.originalPrice = originalPriceBag
				scriptOffer.prices.pop()
			}
		}
	}
	else if ( scriptOffer.offerType == GRX_OFFERTYPE_DEFAULT || scriptOffer.offerType == GRX_OFFERTYPE_PYS )
	{
		
		
		scriptOffer.originalPrice = null

		if ( "originalprice" in scriptOffer.attributes && scriptOffer.attributes.originalprice != "0" )
		{
			ItemFlavor ornull singleCurrencyFlav = null
			foreach( price in scriptOffer.prices )
			{
				if ( price.flavors[0] == GRX_CURRENCIES[GRX_CURRENCY_PREMIUM] )
				{
					Assert( price.flavors.len() == 1, "NYI!" )
					singleCurrencyFlav = price.flavors[0]
				}
			}

			if ( singleCurrencyFlav != null  )
			{
				expect ItemFlavor( singleCurrencyFlav )
				scriptOffer.originalPrice = MakeItemFlavorBag( {
					[singleCurrencyFlav] = int(scriptOffer.attributes.originalprice),
				} )
			}
			else
			{
				
				
				GRX_Warning( "No AC price on offer but original price was set on Offer: " + scriptOffer.offerAlias )
			}
		}
	}
}



void function GRX_InitScriptOfferPricesFromStoreOffer( GRXStoreOffer codeOffer, GRXScriptOffer scriptOffer, array<string> offerProblems )
{
	foreach ( int priceIdx, GRXStoreOfferPrice storeOfferPrice in codeOffer.prices )
	{
		ItemFlavorBag price
		foreach ( int currencyIndex, int currencyQuantity in storeOfferPrice.currencies )
		{
			ItemFlavor currencyFlav = GRX_CURRENCIES[currencyIndex]

			if ( currencyQuantity < 0 )
			{
				if ( currencyQuantity != -1 )
				{
					offerProblems.append( format( "Price #%d currency '%s' has bad quantity: %d", priceIdx, string(ItemFlavor_GetAsset( currencyFlav )), currencyQuantity ) )
				}
				continue
			}

			price.flavors.append( currencyFlav )
			price.quantities.append( currencyQuantity )
		}
		if ( price.flavors.len() == 0 )
		{
			continue
		}

		if ( storeOfferPrice.priceAlias == "" )
		{
			offerProblems.append( format( "Missing alias for price #%d", priceIdx ) )
			continue
		}

		scriptOffer.priceAliases.append( storeOfferPrice.priceAlias )
		scriptOffer.prices.append( price )
	}
}



string function GRX_InitScriptOfferLocation( GRXScriptOffer scriptOffer, bool isIncremental )
{
	string storeLocation = ""

	if ( "location" in scriptOffer.attributes )
	{
		
		
		

			bool isStoreV2Enabled = GRX_AreStoreSectionsEnabled()
			if ( ( isStoreV2Enabled && GRX_IsStoreV1Location( scriptOffer.attributes.location ) ) ||
				 ( !isStoreV2Enabled && scriptOffer.isStoreV2Offer ) )
			{
				return storeLocation
			}


		storeLocation = scriptOffer.attributes.location

		if ( storeLocation != "" )
		{
			foreach( GRXStoreOfferItem item in scriptOffer.items )
			{
				ItemFlavor itemFlav = GetItemFlavorByGRXIndex( item.itemIdx )
				ItemFlavorPurchasabilityInfo ifpi = fileLevel.itemFlavorPurchasabilityInfoMap[itemFlav]

				if ( scriptOffer.prices.len() > 0 )
				{
					if ( !( storeLocation in ifpi.locationToDedicatedStoreOffersMap ) )
					{
						ifpi.locationToDedicatedStoreOffersMap[storeLocation] <- []
					}

					array<GRXScriptOffer> locationOffers = ifpi.locationToDedicatedStoreOffersMap[storeLocation]
					if ( !locationOffers.contains( scriptOffer ) )
					{
						locationOffers.append( scriptOffer )
					}
				}
				else
				{
					if ( storeLocation in ifpi.locationToDedicatedStoreOffersMap )
					{
						ifpi.locationToDedicatedStoreOffersMap[storeLocation].fastremovebyvalue( scriptOffer )
					}
				}
			}

			if ( !isIncremental )
			{
				if ( !(storeLocation in fileLevel.locationOffersMap) )
				{
					fileLevel.locationOffersMap[storeLocation] <- []
				}
				fileLevel.locationOffersMap[storeLocation].append( scriptOffer )

				fileLevel.offerAliasToOfferMap[scriptOffer.offerAlias] <- scriptOffer
			}
		}
	}

	return storeLocation
}



void function GRX_InitScriptOfferFromStoreOffer( GRXStoreOffer codeOffer, GRXScriptOffer scriptOffer )
{
	bool isOfferRestricted = GRX_IsOfferRestricted()
	array<string> offerProblems = []
	foreach ( GRXStoreOfferItem item in codeOffer.items )
	{
		if ( !IsValidItemFlavorGRXIndex( item.itemIdx ) )
		{
			offerProblems.append( format( "Invalid GRX index: %d", item.itemIdx ) )
			continue
		}

		ItemFlavor outputFlav = GetItemFlavorByGRXIndex( item.itemIdx )

		scriptOffer.items.append( item )

		bool foundMatchingOutputBagEntry = false
		foreach ( int existingOutputIdx, ItemFlavor existingOutputFlav in scriptOffer.output.flavors )
		{
			if ( outputFlav == existingOutputFlav )
			{
				foundMatchingOutputBagEntry = true
				scriptOffer.output.quantities[existingOutputIdx] += item.itemQuantity
			}
		}
		if ( !foundMatchingOutputBagEntry )
		{
			scriptOffer.output.flavors.append( outputFlav )
			scriptOffer.output.quantities.append( item.itemQuantity )
		}
	}

	scriptOffer.attributes = clone codeOffer.attrs

	if ( isOfferRestricted && GRX_IsOfferRestrictedByOfferAttributes( scriptOffer ) )
		scriptOffer.isAvailable = false

	if( scriptOffer.items.len() > 1 )
		scriptOffer.items.sort( SortStoreOfferItems )

	GRX_InitScriptOfferPricesFromStoreOffer( codeOffer, scriptOffer, offerProblems )

	if ( scriptOffer.prices.len() == 0 )
	{
		GRX_Info( "Offer %s has no valid prices and will not display", codeOffer.offerAlias )
	}

	if ( !("location" in codeOffer.attrs) && codeOffer.offerType != GRX_OFFERTYPE_PYS )
	{
		offerProblems.append( "Missing 'location' attribute" )
	}

	if ( offerProblems.len() > 0 )
	{
		GRX_Warning( "Offer %s %s has problems: - %s", codeOffer.offerAlias, DEV_GRX_DescribeOffer( scriptOffer ), offerProblems.join( " - " ) )
		return 
	}

	ItemFlavor flav = GetItemFlavorByGRXIndex( scriptOffer.items[0].itemIdx )
#if DEV
		if ( fileVM.grxStorePreviewItem != "" )
			flav = DEV_GetItemFlavorByGRXRef( fileVM.grxStorePreviewItem )
#endif

	scriptOffer.offerAlias = codeOffer.offerAlias
	scriptOffer.offerType = codeOffer.offerType
	scriptOffer.isGiftable = codeOffer.isSparkable
	scriptOffer.purchaseCount = codeOffer.purchaseCount
	scriptOffer.ineligibilityCode = codeOffer.ineligibilityCode


	if ( "isstore2" in codeOffer.attrs && codeOffer.attrs["isstore2"] == "true" )
	{
		scriptOffer.isStoreV2Offer = true
	}


	string storeLocation = GRX_InitScriptOfferLocation( scriptOffer, false )

	
	if ( "offertitleloc" in codeOffer.attrs )
	{
		scriptOffer.titleText = "#" + codeOffer.attrs["offertitleloc"];
	}
	else
	{
		scriptOffer.titleText = ( "offertitle" in scriptOffer.attributes ? scriptOffer.attributes["offertitle"] : ItemFlavor_GetLongName( flav ) )
	}

	if ( scriptOffer.titleText.len() == 0 )
	{
		GRX_Warning( "scriptOffer.titleText is empty. offerAlias " + scriptOffer.offerAlias )
	}

	if ( "offerdescription" in scriptOffer.attributes )
	{
		scriptOffer.descText = scriptOffer.attributes["offerdescription"]
	}
	else if ( scriptOffer.output.flavors.len() > 1 )
	{
		scriptOffer.descText= ItemFlavor_GetRewardShortDescription( flav )
	}
	else
	{
		scriptOffer.descText = ItemFlavor_GetTypeName( flav )
	}

	scriptOffer.imageRef = ("imageref" in codeOffer.attrs ? codeOffer.attrs.imageref : "")
	scriptOffer.binkRef = ("binkref" in codeOffer.attrs ? codeOffer.attrs.binkref : "")
	scriptOffer.tagText = ("tag" in codeOffer.attrs ? codeOffer.attrs.tag : "")
	scriptOffer.seasonTag = ("seasontag" in codeOffer.attrs ? codeOffer.attrs.seasontag : "")

	SetOriginalPriceForGRXScriptOffer( scriptOffer )

	scriptOffer.tooltipTitle = ("tooltiptitle" in codeOffer.attrs ? codeOffer.attrs.tooltiptitle : "")
	scriptOffer.tooltipDesc = ("tooltipdesc" in codeOffer.attrs ? codeOffer.attrs.tooltipdesc : "")
	scriptOffer.prereqText = ("prereqtext" in codeOffer.attrs ? codeOffer.attrs.prereqtext : "")
	scriptOffer.purchaseLimit = ( "purchaselimit" in scriptOffer.attributes ? scriptOffer.attributes["purchaselimit"].tointeger() : 0 )
	scriptOffer.displayPriority = ( "displaypriority" in codeOffer.attrs ? int(codeOffer.attrs.displaypriority) : 0 )
	scriptOffer.expireTime = ("expireSeconds" in codeOffer.attrs ? int(codeOffer.attrs.expireSeconds) + GetUnixTimestamp() : 0)

	if ( GetConVarBool( "assetdownloads_enabled" ) && IsLobby() && scriptOffer.imageRef != "" )
		RunClientScript( "RequestDownloadedImagePakLoad", scriptOffer.imageRef, ePakType.DL_STORE_TALL )

	bool hasPrereq = ("prereq" in codeOffer.attrs)
	if ( hasPrereq )
	{
		string ref = codeOffer.attrs["prereq"]

		
		ItemFlavor prereqFlav
		bool foundPrereq
		foreach ( ItemFlavor iterFlav in GetAllItemFlavorsCosmetic() )
		{
			if ( ItemFlavor_GetGRXMode( iterFlav ) != eItemFlavorGRXMode.NONE && ItemFlavor_GetGRXAlias( iterFlav ) == ref )
			{
				prereqFlav = iterFlav
				foundPrereq = true
				break
			}
		}

		Assert( foundPrereq, "Store offer has invalid prereq: " + ref )
		if ( !foundPrereq )
			return

		scriptOffer.prereq = prereqFlav
	}

	if( storeLocation != "" )
	{
		if ( scriptOffer.isStoreV2Offer )
		{

			AddOfferToStoreSection( storeLocation, scriptOffer )




		}
		else
		{
			ProcessColumnData( storeLocation, scriptOffer, codeOffer )
		}
	}
}


#if DEV
void function PrintItemPurchasabilityForGRXRef( string ref )
{
	foreach ( int grxIndex, ItemFlavor flav in fileLevel.grxIndexItemFlavorMap )
	{
		if ( ItemFlavor_GetGRXAlias( flav ) == ref )
		{
			ItemFlavorPurchasabilityInfo ifpi = fileLevel.itemFlavorPurchasabilityInfoMap[flav]
			ifpi.isPurchasableAtAll = (ifpi.craftingOfferOrNull != null || ifpi.locationToDedicatedStoreOffersMap.len() > 0)
			printt( "Is Item ", ref, " directly purchasable: ", ifpi.isPurchasableAtAll )
			return
		}
	}
	printt( "Item ", ref, " was not found in sh_grx fileLevel.grxIndexItemFlavorMap." )
}
#endif


void function HandleGRXOffersRefreshed( int offersState, array< GRXCraftingOffer > craftingOffers, array< GRXStoreOffer > storeOffers )
{
	bool isOfferRestricted = GRX_IsOfferRestricted()

	fileLevel.storeOfferColumns.clear()
	fileLevel.specialsStoreOfferColumns.clear()
	fileLevel.seasonalStoreOfferColumns.clear()
	fileLevel.locationOffersMap.clear()
	fileLevel.offerAliasToOfferMap.clear()

		ClearAllStoreV2Offers()

	foreach ( ItemFlavor itemFlavor, ItemFlavorPurchasabilityInfo ifpi in fileLevel.itemFlavorPurchasabilityInfoMap )
		ifpi.locationToDedicatedStoreOffersMap.clear()

	foreach ( GRXCraftingOffer codeOffer in craftingOffers )
	{
		if ( !IsValidItemFlavorGRXIndex( codeOffer.itemIdx ) )
			continue

		ItemFlavor flav = GetItemFlavorByGRXIndex( codeOffer.itemIdx )

		ItemFlavorPurchasabilityInfo ifpi = fileLevel.itemFlavorPurchasabilityInfoMap[flav]

		Assert( codeOffer.craftingPrice > 0 )
		if ( codeOffer.craftingPrice > 0 )
		{
			GRXScriptCraftingOffer scriptOffer

			if ( isOfferRestricted && GRX_IsItemCoveredByOfferRestrictions( flav ) )
				scriptOffer.isAvailable = false

			scriptOffer.craftingPrice = codeOffer.craftingPrice
			scriptOffer.flavor = flav

			ifpi.craftingOfferOrNull = scriptOffer
		}
		else
		{
			ifpi.craftingOfferOrNull = null
		}
	}

	foreach ( GRXStoreOffer codeOffer in storeOffers )
	{
		GRXScriptOffer scriptOffer
		GRX_InitScriptOfferFromStoreOffer( codeOffer, scriptOffer )
	}

	SortAllScriptOffers()

	foreach ( int grxIndex, ItemFlavor flav in fileLevel.grxIndexItemFlavorMap )
	{
		ItemFlavorPurchasabilityInfo ifpi = fileLevel.itemFlavorPurchasabilityInfoMap[flav]
		ifpi.isPurchasableAtAll = (ifpi.craftingOfferOrNull != null || ifpi.locationToDedicatedStoreOffersMap.len() > 0)
	}

	PlayerGRXScriptState scriptState = GetPlayerGRXScriptState( GetLocalClientPlayer() )
	scriptState.areOffersReady = (offersState == GRX_OFFERSSTATE_READY)
	scriptState.areOffersDirty = !scriptState.areOffersReady





	foreach ( void functionref() cb in fileLevel.onGRXOffersRefreshedCallbacks )
		cb()
}

GRXScriptOffer function GRX_ScriptOfferFromCraftingOffer( GRXScriptCraftingOffer craftOffer )
{
	ItemFlavor flav = craftOffer.flavor

	GRXScriptOffer scriptOffer
	scriptOffer.isCraftingOffer = true
	scriptOffer.isAvailable = craftOffer.isAvailable

	ItemFlavorBag price
	price.flavors.append( GRX_CURRENCIES[GRX_CURRENCY_CRAFTING] )
	price.quantities.append( craftOffer.craftingPrice )
	scriptOffer.prices.append( price )

	
	scriptOffer.output.flavors.append( flav )
	scriptOffer.output.quantities.append( 1 )

	
	scriptOffer.titleText = ItemFlavor_GetLongName( flav )
	scriptOffer.descText = ItemFlavor_GetTypeName( flav )
	scriptOffer.image = ItemFlavor_GetIcon( flav )

	return scriptOffer
}

bool function ProcessPrereqOffer( GRXScriptOffer scriptOffer, array<array<array<GRXScriptOffer> > > storeOfferColumns )
{
	foreach ( colIdx, rowArray in storeOfferColumns )
	{
		for ( int rowIdx = 0; rowIdx < rowArray.len(); rowIdx++ )
		{
			array<GRXScriptOffer> offerArray = rowArray[rowIdx]

			foreach ( flav in offerArray[0].output.flavors )
			{
				if ( flav != expect ItemFlavor( scriptOffer.prereq ) )
					continue

				fileLevel.storeOfferColumns[colIdx][rowIdx].append( scriptOffer )
				return true
			}
		}
	}
	return false
}

void function SortAllScriptOffers()
{

		SortStoreSectionData( fileLevel.storeSectionInfoMap )

	SortScriptOffers( fileLevel.storeOfferColumns )
	SortScriptOffers( fileLevel.specialsStoreOfferColumns )
	SortScriptOffers( fileLevel.seasonalStoreOfferColumns )
}

void function SortScriptOffers( array<array<array<GRXScriptOffer> > > storeOfferColumns )
{
	foreach ( colIdx, rowArray in storeOfferColumns )
	{
		foreach ( rowIdx, offerArray in rowArray )
		{
			UpdateScriptOffersPriority( offerArray )
			offerArray.sort( SortScriptOffer )
		}
	}
}

int function SortScriptOffer( GRXScriptOffer a, GRXScriptOffer b )
{
	if ( a.displayPriority > b.displayPriority )
		return 1
	else if ( b.displayPriority > a.displayPriority )
		return -1

	if ( a.expireTime > b.expireTime )
		return 1
	else if ( b.expireTime > a.expireTime )
		return -1

	return 0
}

void function UpdateScriptOffersPriority( array<GRXScriptOffer> offerArray )
{
	if ( GRX_IsInventoryReady() )
	{
		foreach ( GRXScriptOffer offer in offerArray )
		{
			UpdateScriptOfferPriority( offer )
		}
	}
}

void function UpdateScriptOfferPriority( GRXScriptOffer offer )
{
	const int MAX_OFFER_COUNT_PER_PANEL = 5

	bool isOfferFullyClaimed = GRXOffer_IsFullyClaimed( offer )

	if ( isOfferFullyClaimed && offer.displayPriority < MAX_OFFER_COUNT_PER_PANEL )
	{
		
		offer.displayPriority += MAX_OFFER_COUNT_PER_PANEL
	}
}



void function ServerCallback_UpdatePlayerLastLoggedInTimestamp( int timestamp )
{
	if ( fileLevel.lastLoggedInTimestamp == 0 )
	{
		fileLevel.lastLoggedInTimestamp = timestamp
	}
}

bool function SectionShouldBeMarkedAsNew( int markedAsNewDate )
{
	return markedAsNewDate > fileLevel.lastLoggedInTimestamp
}

bool function SectionIdIsValid( int sectionId )
{
	return sectionId >= 0 && sectionId < GRX_MAX_STORE_SECTIONS
}

bool function HighestPagesSeenArrayIsValid()
{
	return fileLevel.smartMerchData.highestPagesSeen.len() == GRX_MAX_STORE_SECTIONS
}

void function SetDefaultSmartMerchData()
{
	fileLevel.smartMerchData.highestPagesSeen.clear()
	for ( int i = 0; i < GRX_MAX_STORE_SECTIONS; ++i )
	{
		fileLevel.smartMerchData.highestPagesSeen.append( 0 )
	}
	fileLevel.smartMerchData.lastSectionVisited = 0
}

int function GetHighestPageForSection( int sectionId )
{
	if ( !SectionIdIsValid( sectionId ) )
	{
		Assert( false, format("Invalid section id %d. Expected a value value X where 0 <= X < %d.", sectionId, GRX_MAX_STORE_SECTIONS ) )
		return 0
	}
	if ( !HighestPagesSeenArrayIsValid() )
	{
		Assert( false, format( "Tried to get highest page for section %d but page info is misconfigured.", sectionId ) )
		return 0
	}
	return fileLevel.smartMerchData.highestPagesSeen[sectionId]
}

bool function HasSectionBeenSeen( int sectionId )
{
	return GetHighestPageForSection( sectionId ) > 0
}

int function GetMostRecentlySeenSection()
{
	return fileLevel.smartMerchData.lastSectionVisited
}

void function SetHighestPageSeenForSection( int sectionId, int highestPageSeen )
{
	if ( !SectionIdIsValid( sectionId ) )
	{
		Assert( false, format("Invalid section id %d. Expected a value X where 0 <= X < %d.", sectionId, GRX_MAX_STORE_SECTIONS ) )
		return
	}

	fileLevel.smartMerchData.highestPagesSeen[sectionId] = highestPageSeen
}

void function SetLastSectionVisited( int sectionId )
{
	if ( !SectionIdIsValid( sectionId ) )
	{
		Assert( false, format("Invalid section id %d. Expected a value X where 0 <= X < %d.", sectionId, GRX_MAX_STORE_SECTIONS ) )
		return
	}

	fileLevel.smartMerchData.lastSectionVisited = sectionId
}

void function ClearHighestPageSeenForSection( int sectionId )
{
	if ( !SectionIdIsValid( sectionId ) )
	{
		Assert( false, format("Invalid section id %d. Expected a value X where 0 <= X < %d.", sectionId, GRX_MAX_STORE_SECTIONS ) )
		return
	}

	fileLevel.smartMerchData.highestPagesSeen[sectionId] = 0
}



void function UpdateSmartMerchandisingData()
{
	array<int> smartMerchInts

	for ( int i = 0; i < GRX_MAX_STORE_SECTIONS; ++i )
	{
		smartMerchInts.append( fileLevel.smartMerchData.highestPagesSeen[i] )
	}

	smartMerchInts.append( fileLevel.smartMerchData.lastSectionVisited )

	GRX_UpdateSmartMerchandisingData( smartMerchInts )
}

bool function GRX_IsStoreV1Location( string storeLocation )
{
	return storeLocation == "shop" || storeLocation == "specials" || storeLocation == "seasonal"
}

void function ClearAllStoreV2Offers()
{
	fileLevel.storeSectionInfoMap.clear()
}

void function UpdateStoreV2ScriptOfferPriority( GRXScriptOffer offer, int sectionLength )
{
	bool isOfferFullyClaimed = GRXOffer_IsFullyClaimed( offer )

	if ( isOfferFullyClaimed && offer.displayPriority < sectionLength )
	{
		
		offer.displayPriority += sectionLength
	}
}


void function AddOfferToStoreSection( string storeLocation, GRXScriptOffer scriptOffer )
{
	
	if ( !( storeLocation in eStoreSections ) )
	{
		Assert( false, "Received invalid store location " + storeLocation )
		return
	}

	int storeSectionEnum = eStoreSections[storeLocation]
	if ( ( storeSectionEnum in fileLevel.storeSectionInfoMap ) )
	{
		fileLevel.storeSectionInfoMap[storeSectionEnum].offers.append( scriptOffer )
	}
	else
	{
		StoreSectionInfo sectionInfo
		
		
		sectionInfo.sectionId = storeSectionEnum
		sectionInfo.offers = [scriptOffer]
		fileLevel.storeSectionInfoMap[storeSectionEnum] <- sectionInfo
	}
}


void function SortStoreSectionData( table<int, StoreSectionInfo > storeSectionData )
{
	if ( !GRX_IsInventoryReady() )
	{
		return
	}
	foreach ( int location, StoreSectionInfo sectionInfo in storeSectionData )
	{
		sectionInfo.offers.sort( SortScriptOffer )
	}
}

string function GetCurrentEventSectionName()
{
	return GetCurrentFlexSectionName( EventSectionNameToDateMap )
}

string function GetCurrentFlexSectionName( table< string, array<string> > sectionNameToDateMap )
{
	int currentTime = GetUnixTimestamp()
	foreach( string sectionName, array<string> dateStringArray in sectionNameToDateMap )
	{
		Assert( dateStringArray.len() == 2,
			"Store 2.0 flex section map has a misconfigured date array. Array must have exactly two elements: a start date string, and an end date string." )
		int ornull startDate = DateTimeStringToUnixTimestamp( dateStringArray[0] )
		int ornull endDate = DateTimeStringToUnixTimestamp( dateStringArray[1] )
		if ( startDate == null || endDate == null )
		{
			Assert( false, "Store 2.0 flex section " + Localize( sectionName ) + " contained a malformed date string. Skipping this section." )
			continue
		}
		expect int( startDate )
		expect int( endDate )
		if ( currentTime > startDate && currentTime < endDate )
		{
			return sectionName
		}
	}
	return ""
}

void function PopulateStoreSectionNames( table<int, StoreSectionInfo > storeSectionData )
{
	foreach ( int location, StoreSectionInfo sectionInfo in storeSectionData )
	{
		
		if ( sectionInfo.sectionName != "" )
		{
			continue
		}
		switch ( location )
		{
			case eStoreSections.Featured:
			{
				sectionInfo.sectionName = "#STORE_V2_SECTION_FEATURED"
				break
			}
			case eStoreSections.Monthly:
			{
				sectionInfo.sectionName = "#STORE_V2_SECTION_MONTHLY"
				break
			}
			case eStoreSections.Recolor:
			{
				sectionInfo.sectionName = "#STORE_V2_SECTION_RECOLORS"
				break
			}
			case eStoreSections.Exotic:
			{
				sectionInfo.sectionName = "#STORE_V2_SECTION_EXOTIC"
				break
			}
			case eStoreSections.BattlepasShop:
			{
				sectionInfo.sectionName = "#STORE_V2_SECTION_BATTLEPASS"
				break
			}
			case eStoreSections.Event:
			{
				sectionInfo.sectionName = GetCurrentFlexSectionName( EventSectionNameToDateMap )
				break
			}
			case eStoreSections.Flex1:
			{
				sectionInfo.sectionName = GetCurrentFlexSectionName( Flex1SectionNameToDateMap )
				break
			}
			case eStoreSections.Flex2:
			{
				sectionInfo.sectionName = GetCurrentFlexSectionName( Flex2SectionNameToDateMap )
				break
			}
			case eStoreSections.Flex3:
			{
				sectionInfo.sectionName = GetCurrentFlexSectionName( Flex3SectionNameToDateMap )
				break
			}
			default:
				GRX_Info( "Unknown store location: %d", location )
				sectionInfo.sectionName = ""
		}
	}
}

int function GetCurrentSectionMarkedAsNewDate( table< string, array<string> > sectionNameToDateMap )
{
	int currentTime = GetUnixTimestamp()
	foreach( string sectionName, array<string> dateStringArray in sectionNameToDateMap )
	{
		Assert( dateStringArray.len() == 2,
			"Store 2.0 flex section map has a misconfigured date array. Array must have exactly two elements: a start date string, and an end date string." )
		int ornull startDate = DateTimeStringToUnixTimestamp( dateStringArray[0] )
		int ornull endDate = DateTimeStringToUnixTimestamp( dateStringArray[1] )
		if ( startDate == null || endDate == null )
		{
			Assert( false, "Store 2.0 flex section " + Localize( sectionName ) + " contained a malformed date string. Skipping this section." )
			continue
		}
		expect int( startDate )
		expect int( endDate )
		if ( currentTime > startDate && currentTime < endDate )
		{
			return startDate
		}
	}
	return LIVE_STORE_START_DATE_UNIX_TIMESTAMP
}

void function PopulateStoreSectionMarkedAsNewDates( table<int, StoreSectionInfo > storeSectionData )
{
	foreach ( int location, StoreSectionInfo sectionInfo in storeSectionData )
	{
		switch ( location )
		{
			case eStoreSections.Featured:
			case eStoreSections.Monthly:
			case eStoreSections.Recolor:
			case eStoreSections.Exotic:
			case eStoreSections.BattlepasShop:
			{
				sectionInfo.markedAsNewDate = LIVE_STORE_START_DATE_UNIX_TIMESTAMP
				break
			}
			case eStoreSections.Event:
			{
				sectionInfo.markedAsNewDate = GetCurrentSectionMarkedAsNewDate( EventSectionNameToDateMap )
				break
			}
			case eStoreSections.Flex1:
			{
				sectionInfo.markedAsNewDate = GetCurrentSectionMarkedAsNewDate( Flex1SectionNameToDateMap )
				break
			}
			case eStoreSections.Flex2:
			{
				sectionInfo.markedAsNewDate = GetCurrentSectionMarkedAsNewDate( Flex2SectionNameToDateMap )
				break
			}
			case eStoreSections.Flex3:
			{
				sectionInfo.markedAsNewDate = GetCurrentSectionMarkedAsNewDate( Flex3SectionNameToDateMap )
				break
			}
			default:
				GRX_Info( "Unknown store location: %d", location )
				sectionInfo.markedAsNewDate = 0
		}
	}
}

table<int, StoreSectionInfo> function GetSortedStoreSectionData()
{
	SortStoreSectionData( fileLevel.storeSectionInfoMap )
	PopulateStoreSectionNames( fileLevel.storeSectionInfoMap )
	PopulateStoreSectionMarkedAsNewDates( fileLevel.storeSectionInfoMap )
	return fileLevel.storeSectionInfoMap
}

#if DEV
void function PrintSortedStoreSectionData()
{
	table<int, StoreSectionInfo> sortedStoreSectionData = GetSortedStoreSectionData()
	foreach ( int location, StoreSectionInfo sectionInfo in sortedStoreSectionData )
	{
		printt( "Section name: ", sectionInfo.sectionName )
		printt( "Section id: ", sectionInfo.sectionId )
		printt( "Marked as new date: ", sectionInfo.markedAsNewDate )
		printt( "Offers for location ", GetSectionLocationNameFromEnum( location ) )
		foreach( GRXScriptOffer offer in sectionInfo.offers )
		{
			printt( "Offer ", offer.offerAlias, " with displayPriority = ", offer.displayPriority )
		}
	}
}

string function GetSectionLocationNameFromEnum( int location )
{
	foreach ( string key, int val in eStoreSections )
	{
		if ( val == location)
			return key
	}
	return "INVALID LOCATION"
}

void function DEV_TestUpdateSmartMerchandisingData()
{
	array<int> smartMerchInts = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 10 ]
	GRX_UpdateSmartMerchandisingData( smartMerchInts )
}

void function DEV_PrintSmartMerchandisingData()
{
	if ( !HighestPagesSeenArrayIsValid() )
	{
		printt( "Smart merch highest page seen array has " + fileLevel.smartMerchData.highestPagesSeen.len() + " elements but we were expecting " + GRX_MAX_STORE_SECTIONS )
	}

	printt("Now printing out smart merch data...")
	for ( int i = 0; i < GRX_MAX_STORE_SECTIONS; ++i )
	{
		printt("\tsection id = " + i + ", highest page seen = " + fileLevel.smartMerchData.highestPagesSeen[i] )
	}

	printt( "\tlast section visited is " + fileLevel.smartMerchData.lastSectionVisited )
}
#endif



void function ProcessColumnData( string storeLocation, GRXScriptOffer scriptOffer, GRXStoreOffer codeOffer )
{
	if( storeLocation != "shop" && storeLocation != "specials" && storeLocation != "seasonal")
		return

	if( !( "storerow" in codeOffer.attrs ) || !( "storecolumn" in codeOffer.attrs ) )
		return

	int row = int( codeOffer.attrs["storerow"] )
	int col = int( codeOffer.attrs["storecolumn"] )

	if ( row > 0 && col > 0 && scriptOffer.expireTime > GetUnixTimestamp() )
	{
		int colIdx = col - 1, rowIdx = row - 1

		if( storeLocation == "specials" )
		{
			while ( fileLevel.specialsStoreOfferColumns.len() < colIdx + 1 )
				fileLevel.specialsStoreOfferColumns.append( [] )

			while ( fileLevel.specialsStoreOfferColumns[colIdx].len() < rowIdx + 1 )
				fileLevel.specialsStoreOfferColumns[colIdx].append( [] )

			fileLevel.specialsStoreOfferColumns[colIdx][rowIdx].append( scriptOffer )
		}
		else if ( storeLocation == "seasonal" )
		{
			while ( fileLevel.seasonalStoreOfferColumns.len() < colIdx + 1 )
				fileLevel.seasonalStoreOfferColumns.append( [] )

			while ( fileLevel.seasonalStoreOfferColumns[colIdx].len() < rowIdx + 1 )
				fileLevel.seasonalStoreOfferColumns[colIdx].append( [] )

			fileLevel.seasonalStoreOfferColumns[colIdx][rowIdx].append( scriptOffer )
		}
		else
		{
			while ( fileLevel.storeOfferColumns.len() < colIdx + 1 )
				fileLevel.storeOfferColumns.append( [] )

			while ( fileLevel.storeOfferColumns[colIdx].len() < rowIdx + 1 )
				fileLevel.storeOfferColumns[colIdx].append( [] )

			fileLevel.storeOfferColumns[colIdx][rowIdx].append( scriptOffer )
		}
	}

	GRX_Info( "store_offer - col: %d, row: %d, flav: %s, expireTime: %d, descText: %s, titleText: %s",
		col,
		row,
		DEV_DescItemFlavor( scriptOffer.output.flavors[0] ),
		scriptOffer.expireTime,
		scriptOffer.descText,
		scriptOffer.titleText
	)

}




const array<int> HIGH_PRIORITY_ITEM_TYPES = [
	eItemType.battlepass,
	eItemType.character,
]


const table<int, int> ITEM_TYPE_PRIORITY_MAP = {
	[eItemType.battlepass] = 110,
	[eItemType.battlepass_purchased_xp] = 109,
	[eItemType.character] =  100,
	[eItemType.artifact_component_blade] =  94,
	[eItemType.artifact_component_theme] =  93,
	[eItemType.artifact_component_power_source] =  92,
	[eItemType.artifact_component_activation_emote] =  91,
	[eItemType.artifact_component_deathbox] =  90,
	[eItemType.melee_skin] = 82,
	[eItemType.character_skin] = 81,
	[eItemType.character_execution] = 80,



	[eItemType.weapon_skin] = 71,
	[eItemType.weapon_charm] = 70,
	[eItemType.gladiator_card_stance] = 65,
	[eItemType.gladiator_card_frame] = 64,
	[eItemType.gladiator_card_intro_quip] = 63,
	[eItemType.gladiator_card_kill_quip] = 62,
	[eItemType.gladiator_card_stat_tracker] = 61,
	[eItemType.gladiator_card_badge] = 60,
	[eItemType.music_pack] = 52,
	[eItemType.loadscreen] = 51,
	[eItemType.skydive_emote] = 50,
	[eItemType.character_emote] = 45,
	[eItemType.emote_icon] = 40,
	[eItemType.reward_set_tracker] = 6,
	[eItemType.sticker] = 5,
	[eItemType.battlepass_purchased_xp] = 4,
	[eItemType.voucher] = 3,
	[eItemType.battlepass_presale_voucher] = 2,
	[eItemType.account_pack] = 1,
	[eItemType.image_2d] = 0,
}

int function SortStoreOfferItems( GRXStoreOfferItem itemA, GRXStoreOfferItem itemB )
{
	ItemFlavor a = GetItemFlavorByGRXIndex( itemA.itemIdx )
	ItemFlavor b = GetItemFlavorByGRXIndex( itemB.itemIdx )

	int itemTypeA = ItemFlavor_GetType( a )
	int itemTypeB = ItemFlavor_GetType( b )

	Assert( itemTypeA in ITEM_TYPE_PRIORITY_MAP, format( "Found item type in store offer that does NOT exist in ITEM_TYPE_PRIORITY_MAP. Item A %s has type '%s'", ItemFlavor_GetGRXAlias( a ), ItemFlavor_GetTypeName( a ) ) )
	Assert( itemTypeB in ITEM_TYPE_PRIORITY_MAP, format( "Found item type in store offer that does NOT exist in ITEM_TYPE_PRIORITY_MAP. Item B %s has type '%s'", ItemFlavor_GetGRXAlias( b ), ItemFlavor_GetTypeName( b ) ) )

	bool itemTypePrioExistsA = itemTypeA in ITEM_TYPE_PRIORITY_MAP
	bool itemTypePrioExistsB = itemTypeB in ITEM_TYPE_PRIORITY_MAP

	int itemTypePriorityA = itemTypePrioExistsA ? ITEM_TYPE_PRIORITY_MAP[itemTypeA] : 0
	int itemTypePriorityB = itemTypePrioExistsB ? ITEM_TYPE_PRIORITY_MAP[itemTypeB] : 0

	
	bool hasHighestPriorityItemType = false
	foreach ( int highPriorityType in HIGH_PRIORITY_ITEM_TYPES )
		if ( itemTypeA == highPriorityType || itemTypeB == highPriorityType )
			hasHighestPriorityItemType = true

	int result = hasHighestPriorityItemType ? SortLowestFirst( itemTypePriorityA, itemTypePriorityB ) : 0
	if ( result != 0 )
		return result

	result = SortLowestFirst( ItemFlavor_GetGRXMode( b ), ItemFlavor_GetGRXMode( a ) )
	if ( result != 0 )
		return result

	result = SortLowestFirst( ItemFlavor_GetQuality( a ), ItemFlavor_GetQuality( b ) )
	if ( result != 0 )
		return result

	return SortLowestFirst( itemTypePriorityA, itemTypePriorityB )
}

int function SortLowestFirst( int a, int b )
{
	if ( a < b )
		return 1
	else if ( b < a )
		return -1

	return 0
}

int function SortOffersBySlot( GRXScriptOffer a, GRXScriptOffer b )
{
	int aSlot = ("slot" in a.attributes ? int(a.attributes["slot"]) : 99999)
	int bSlot = ("slot" in b.attributes ? int(b.attributes["slot"]) : 99999)
	if ( aSlot != bSlot )
		return bSlot - aSlot

	return 0
}




string function DEV_GRX_DescribeOffer( GRXScriptOffer offer )
{
	array<string> priceDescs = []
	foreach ( int priceIdx, ItemFlavorBag price in offer.prices )
		priceDescs.append( format( "price%d= %s", priceIdx, DEV_DescribeItemFlavorBag( price ) ) )
	return format( "[contents= %s; %s]", DEV_DescribeItemFlavorBag( offer.output ), priceDescs.join( "; " ) )
}




void function ShowGRXErrorDialogue( string optionalMessage = "" )
{
	EmitUISound( "menu_deny" )

	CloseAllDialogs()

	ConfirmDialogData data
	data.headerText = "#GRX_ERROR_HEADER"
	data.messageText = Localize( "#GRX_ERROR_GENERIC" )
	if ( optionalMessage != "" )
		data.messageText += "\n\n" + Localize( optionalMessage )
	data.contextImage = $"ui/menu/common/dialog_error"

	OpenOKDialogFromData( data )
}




ItemFlavorBag ornull WORKAROUND_GRXPackOpened_Contents = null
void function ClientToUI_WORKAROUND_GRXPackOpened_Start( int associatedError )
{
	ItemFlavorBag bag
	bag.associatedError = associatedError
	WORKAROUND_GRXPackOpened_Contents = bag
}
void function ClientToUI_WORKAROUND_GRXPackOpened_Entry( int guid, int qty )
{
	ItemFlavorBag bag = expect ItemFlavorBag(WORKAROUND_GRXPackOpened_Contents)
	bag.flavors.append( GetItemFlavorByGUID( guid ) )
	bag.quantities.append( qty )
}
void function ClientToUI_WORKAROUND_GRXPackOpened_Finish()
{
	fileLevel.mostRecentPackOpeningResultsOrNull = WORKAROUND_GRXPackOpened_Contents
	WORKAROUND_GRXPackOpened_Contents = null
}

































































































































































































































































































































































































































































































































void function AssertCurrencyBundlePlaylistVarsAreValid( ItemFlavor bundle )
{
	
	if ( GRXCurrencyBundle_GetValue( bundle ) <= 0 )
		GRX_Warning( "Playlist must contain this var: %s", "grx_" + ItemFlavor_GetGRXAlias( bundle ) + "_count" )
}

void function RegisterStickerPacksWithRewards( ItemFlavor pack )
{
	if ( !GetGlobalSettingsBool( ItemFlavor_GetAsset( pack ), "hasStickers" ) )
	{
		return
	}

	if ( GRXPack_GetStickerCompletionRewardSequence( pack ) != "" )
	{
		fileLevel.stickerPacksWithRewards.append( pack )
	}
}

array<ItemFlavor> function GRX_GetStickerPacksWithRewards()
{
	return fileLevel.stickerPacksWithRewards
}





























bool function Escrow_IsPlayerTrusted_Internal( entity player )
{
#if DEV
		if ( GetConVarInt( "escrow_is_player_trusted" ) == 1 ) 
		{
			return true
		}
		else if ( GetConVarInt( "escrow_is_player_trusted" ) == -1 ) 
		{
			return false
		}
#endif

	if ( !IsValid( player ) )
		return false


	int trustOverrideValue = GRX_GetAccountIntAttribute( TRUSTED_OVERRIDE_ACCOUNT_ATTRIBUTE_NAME )

	switch ( trustOverrideValue )
	{
		case GRX_TRUSTED_OVERRIDE_STATE_UNTRUSTED:
			
			return false
		case GRX_TRUSTED_OVERRIDE_STATE_UNKNOWN:
			
			break
		case GRX_TRUSTED_OVERRIDE_STATE_TRUSTED:
			
			return true
		default:
			GRX_Warning("Trust override account attribute value of " + trustOverrideValue + " is unhandled")
			break
	}


	int currentXP = GetPlayerAccountXPProgress( ToEHI( player ) )
	int currentLevel = GetAccountLevelForXP( currentXP )

	
	if ( currentLevel < ( GetConVarInt( "mtx_escrow_trusted_level" ) - 1 ) )
		return false

	return true
}



bool function HasEscrowBalance()
{
	int escrowBalance = GRXCurrency_GetPlayerBalance( GetLocalClientPlayer(), GRX_CURRENCIES[GRX_CURRENCY_ESCROW] )
	return escrowBalance > 0
}



bool function Escrow_IsPlayerTrusted()
{
	return Escrow_IsPlayerTrusted_Internal( GetLocalClientPlayer() )
}















bool function GRX_IsOfferRestricted( entity player = null )
{




	if ( player == null )
		player = GetLocalClientPlayer()









		Assert( player == GetLocalClientPlayer() )
		PlayerGRXScriptState grxState = GetPlayerGRXScriptState( player )


	return grxState.isOfferRestricted
}



bool function GRX_IsOfferRestrictedByOfferAttributes( GRXScriptOffer offer )




{

	table<string, string> attributes = offer.attributes




	bool isOfferRestricted = false
	bool hasUnavailableReason =  false

	if ( "unavailableReason" in attributes )
	{
		hasUnavailableReason = true

		offer.unavailableReason = attributes.unavailableReason

	}

	if ( "restrict" in attributes )
	{
		string restrictVal = attributes["restrict"]
		if ( restrictVal == "true" )
			isOfferRestricted = true
	}

	return isOfferRestricted || hasUnavailableReason
}



int function GRX_GetNextCurrencyExpirationAmt( ItemFlavor currencyFlav )
{
	PlayerGRXScriptState grxState = GetPlayerGRXScriptState( GetLocalClientPlayer() )
	if( !grxState.isInventoryReady || grxState.currencies.len() == 0 )
		return 0

	int currencyIndex = GRXCurrency_GetCurrencyIndex( currencyFlav )
	return grxState.currencies[currencyIndex].nextCurrencyExpirationAmt
}




int function GRX_GetNextCurrencyExpirationTime( ItemFlavor currencyFlav )
{
	PlayerGRXScriptState grxState = GetPlayerGRXScriptState( GetLocalClientPlayer() )
	if( !grxState.isInventoryReady || grxState.currencies.len() == 0 )
		return 0

	int currencyIndex = GRXCurrency_GetCurrencyIndex( currencyFlav )
	return grxState.currencies[currencyIndex].nextCurrencyExpirationTime
}




bool function GRX_IsItemCoveredByOfferRestrictions( ItemFlavor flav )
{
	if ( ItemFlavor_GetType( flav ) == eItemType.account_pack )
	{
		
		if ( ItemFlavor_GetQuality( flav, eRarityTier.NONE ) == eRarityTier.MYTHIC )
			return false

		
		ItemFlavor ornull activeBattlePass = GetActiveBattlePass()
		if ( activeBattlePass != null )
		{
			expect ItemFlavor( activeBattlePass )
			ItemFlavor basicPassPack = BattlePass_GetBasicPurchasePack( activeBattlePass )
			ItemFlavor bundlePassPack = BattlePass_GetBundlePurchasePack( activeBattlePass )

			if ( flav == basicPassPack || flav == bundlePassPack )
				return false
		}
		return true
	}

	return false
}



ItemFlavorBag function GRX_MakeItemFlavorBagFromPriceArray( array<int> prices )
{
	ItemFlavorBag priceBag
	foreach ( int currencyIndex, int currencyQuantity in prices )
	{
		ItemFlavor currencyFlav = GRX_CURRENCIES[currencyIndex]

		if ( currencyQuantity <= 0 )
			continue

		priceBag.flavors.append( currencyFlav )
		priceBag.quantities.append( currencyQuantity )
	}
	return priceBag
}








































table<int, int> function GRX_GetPostGameRewards()
{
	
	
	table<int, int> postGameRewards = {}
	entity player = GetLocalClientPlayer()

	if ( !IsLocalClientEHIValid() )
		return postGameRewards

	for ( int persistentArrayIdx = 0; persistentArrayIdx < QUEUED_REWARDS_MAX_COUNT; persistentArrayIdx++ )
	{
		SettingsAssetGUID ornull rewardItemFlavGUID = GetQueuedRewardOrNull( persistentArrayIdx )
		if ( rewardItemFlavGUID == null)
			continue

		expect SettingsAssetGUID( rewardItemFlavGUID )

		SettingsAssetGUID sourceItemFlavGUID   = expect int( GetDialogFlowTablesValueOrPersistence( format( "grxQueuedRewards[%d].sourceGUID", persistentArrayIdx ) ) )
		if ( sourceItemFlavGUID != 0 && IsValidItemFlavorGUID( sourceItemFlavGUID, eValidation.ASSERT ) )
		{
			switch( ItemFlavor_GetType( GetItemFlavorByGUID( sourceItemFlavGUID ) ) )
			{
				case eItemType.challenge: 
					if ( ItemFlavor_GetType( GetItemFlavorByGUID( rewardItemFlavGUID ) ) == eItemType.gladiator_card_badge )
						postGameRewards[ rewardItemFlavGUID ] <- persistentArrayIdx

					break
			}
		}
	}

	return postGameRewards
}



SettingsAssetGUID ornull function GetQueuedRewardOrNull( int persistentArrayIdx )
{
	SettingsAssetGUID rewardItemFlavGUID = expect int( GetDialogFlowTablesValueOrPersistence( format( "grxQueuedRewards[%d].rewardGUIDs[0]", persistentArrayIdx ) ) )
	if ( rewardItemFlavGUID == 0 )
		return null

	if ( !IsValidItemFlavorGUID( rewardItemFlavGUID, eValidation.DONT_ASSERT ) )
	{
		if ( GetCurrentPlaylistVarBool( "grx_purge_unknown_guid_rewards", true ) )
		{
			GRX_Warning( "Purging unknown ItemFlavor GUID " + rewardItemFlavGUID + " found in grxQueuedRewards." )
			GRX_MarkRewardAcknowledged( rewardItemFlavGUID, persistentArrayIdx )
		}
		else
		{
			Assert( false, "Unknown ItemFlavor GUID " + rewardItemFlavGUID + " found in grxQueuedRewards." )
		}
		return null
	}

	bool rewardGiven        = expect bool( GetDialogFlowTablesValueOrPersistence( format( "grxQueuedRewards[%d].rewardGiven", persistentArrayIdx )  ) ) 
	bool rewardAcknowledged = expect bool( GetDialogFlowTablesValueOrPersistence( format( "grxQueuedRewards[%d].rewardAcknowledged", persistentArrayIdx )  )  ) 
	if ( !rewardGiven || rewardAcknowledged )
		return null

	return rewardItemFlavGUID
}




void function GRX_MarkRewardAcknowledged( int rewardItemFlavGUID, int persistentArrayIdx )
{
	SetDialogFlowPersistenceTables( format( "grxQueuedRewards[%d].sourceGUID", persistentArrayIdx ), 0 )
	SetDialogFlowPersistenceTables( format( "grxQueuedRewards[%d].sourceGUID_extraData", persistentArrayIdx ), 0 )
	SetDialogFlowPersistenceTables( format( "grxQueuedRewards[%d].rewardGUIDs[0]", persistentArrayIdx ), 0 )
	SetDialogFlowPersistenceTables( format( "grxQueuedRewards[%d].rewardQuantities[0]", persistentArrayIdx ), 0 )
	SetDialogFlowPersistenceTables( format( "grxQueuedRewards[%d].rewardGiven", persistentArrayIdx ), false )
	SetDialogFlowPersistenceTables( format( "grxQueuedRewards[%d].rewardAcknowledged", persistentArrayIdx ), false )

	if ( IsValidItemFlavorGUID( rewardItemFlavGUID, eValidation.DONT_ASSERT ) || !GetCurrentPlaylistVarBool( "grx_purge_unknown_guid_rewards", true ) )
		Remote_ServerCallFunction( "ClientCallback_acknowledge_reward", persistentArrayIdx, rewardItemFlavGUID )
}



int function GRX_GetGiftingLimitCounter( entity player )
{
	PlayerGRXScriptState grxState = GetPlayerGRXScriptState( player )
	return grxState.giftingLimitCounter
}



int function GRX_GetGiftingLimitResetDate()
{
	PlayerGRXScriptState grxState = GetPlayerGRXScriptState( GetLocalClientPlayer() )
	return grxState.giftingLimitResetDate
}


#if DEV





















#endif




bool function ItemFlavorIsStackable( ItemFlavor itemFlav )
{
	return ItemFlavor_GetGRXMode( itemFlav ) == eItemFlavorGRXMode.PACK ||
	ItemFlavor_GetGRXMode( itemFlav ) == eItemFlavorGRXMode.CONSUMABLE ||
	ItemFlavor_GetGRXMode( itemFlav ) == eItemFlavorGRXMode.CURRENCY
}



bool function GRX_IsLegendOffer( GRXScriptOffer offer )
{
	return offer.output.flavors.len() == 1 && ItemFlavor_GetType( offer.output.flavors[0] ) == eItemType.character
}



bool function GRX_AreStoreSectionsEnabled()
{
	return ( GetConVarBool( "mtx_store_sections_enabled" ) && GetCurrentPlaylistVarBool( "grx_store_sections_enabled", true ) )
}



void function GRX_SetOfferRefreshSuppressed( bool isSuppressed )
{
	GRX_Info( "Setting offer refresh suppressed state: " + isSuppressed )
	Remote_ServerCallFunction( "ClientCallback_SetOfferRefreshSuppressed", isSuppressed )
}



void function GRX_MarkContainerAsSeen( GRXContainerInfo container )
{
	if ( container.containerId.len() == 0 )
	{
		
		GRX_MarkGiftItemsAsSeen( container.timestamp, container.itemIndices )
	}
	else
	{
		GRX_MarkContainerAsSeen_Internal( container.containerId )
	}
}



GRXScriptOffer ornull function GRX_GetScriptOfferFromOfferAlias( string offerAlias )
{
	if ( !( offerAlias in fileLevel.offerAliasToOfferMap ) )
		return null

	return fileLevel.offerAliasToOfferMap[offerAlias]
}




void function UICodeCallback_GRXSmartMerchandisingDataUpdated( array<int> smartMerchandisingData )
{
	Assert( smartMerchandisingData.len() == ( GRX_SMART_MERCHANDISING_DATA_NUM_INTS ) )

	
	fileLevel.smartMerchData.highestPagesSeen.clear()
	for ( int i = 0; i < GRX_MAX_STORE_SECTIONS; ++i )
	{
		fileLevel.smartMerchData.highestPagesSeen.append( smartMerchandisingData[i] )
	}

	fileLevel.smartMerchData.lastSectionVisited = smartMerchandisingData[GRX_SMART_MERCHANDISING_DATA_NUM_INTS - 1]
}









































































#if DEV
































































#endif



const int NUM_MAIN_MILESTONE_PACKS_PER_BUNDLE = 3
ItemFlavor ornull function GetNextMilestoneRewardPack()
{
	ItemFlavor ornull activeEvent = GetActiveMilestoneEvent( GetUnixTimestamp() )
	if ( activeEvent == null )
	{
		return null
	}
	 expect ItemFlavor( activeEvent )

	ItemFlavor mainPackFlav = MilestoneEvent_GetMainPackFlav( activeEvent )
	int mainPackFlavCount =  GRX_GetPackCount( ItemFlavor_GetGRXIndex( mainPackFlav ) )
	ItemFlavor guaranteedPackFlav = MilestoneEvent_GetGuaranteedPackFlav( activeEvent )
	int guaranteedPackFlavCount =  GRX_GetPackCount( ItemFlavor_GetGRXIndex( guaranteedPackFlav ) )

	if ( mainPackFlavCount == 0 || guaranteedPackFlavCount == 0 )
	{
		if ( mainPackFlavCount == 0 && guaranteedPackFlavCount == 0 )
		{
			return null
		}
		if ( guaranteedPackFlavCount == 0 )
		{
			return mainPackFlav
		}
		return guaranteedPackFlav
	}
	if ( fileVM.mainMilestonePacksOpenedThisClientSession >= NUM_MAIN_MILESTONE_PACKS_PER_BUNDLE )
	{
		Assert( fileVM.mainMilestonePacksOpenedThisClientSession == NUM_MAIN_MILESTONE_PACKS_PER_BUNDLE,
			    "fileVM.mainMilestonePacksOpenedThisClientSession should never be incremented greater than NUM_MAIN_MILESTONE_PACKS_PER_BUNDLE.")
		return guaranteedPackFlav
	}
	return mainPackFlav
}

void function UpdateOpenedMilestonePackCounts( ItemFlavor packFlav )
{
	ItemFlavor ornull activeEvent = GetActiveMilestoneEvent( GetUnixTimestamp() )
	if ( activeEvent == null )
	{
		return
	}
	expect ItemFlavor( activeEvent )
	ItemFlavor mainPackFlav = MilestoneEvent_GetMainPackFlav( activeEvent )
	ItemFlavor guaranteedPackFlav = MilestoneEvent_GetGuaranteedPackFlav( activeEvent )

	if ( packFlav != mainPackFlav && packFlav != guaranteedPackFlav )
	{
		return
	}

	int mainPackFlavCount =  GRX_GetPackCount( ItemFlavor_GetGRXIndex( mainPackFlav ) )
	int guaranteedPackFlavCount =  GRX_GetPackCount( ItemFlavor_GetGRXIndex( guaranteedPackFlav ) )

	
	
	
	
	
	
	if ( mainPackFlavCount == 0 || guaranteedPackFlavCount == 0 || packFlav == guaranteedPackFlav )
	{
		fileVM.mainMilestonePacksOpenedThisClientSession = 0
		return
	}
	if ( fileVM.mainMilestonePacksOpenedThisClientSession >= NUM_MAIN_MILESTONE_PACKS_PER_BUNDLE )
	{
		
		
		Assert( false, "A main milestone pack was opened when fileVM.mainMilestonePacksOpenedThisClientSession >= NUM_MAIN_MILESTONE_PACKS_PER_BUNDLE, which is not aligned with the 4-pack guarantee." )
		fileVM.mainMilestonePacksOpenedThisClientSession = 0
		return
	}
	fileVM.mainMilestonePacksOpenedThisClientSession++
}

