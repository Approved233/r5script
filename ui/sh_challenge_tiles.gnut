

global function Sh_Challenge_Tiles_Init
global function ChallengeTiles_IsEnabled

global function ChallengeTile_GetActiveTilesSorted

global function ChallengeTile_GetActiveTileByGUID
global function ChallengeTile_GetActiveBlocks
global function ChallengeTileFlav_GetActiveTilesOfCategory

global function ChallengeTile_RefreshTiles
global function AddCallback_OnChallengeTileAdded
global function RemoveCallback_OnChallengeTileAdded
global function ItemFlavor_GetChallengeRewardButtonImage

global function ChallengeTileFlav_GetAllLinkedCollectionChallenges
global function ChallengeTile_HasDeepLink
global function ChallengeTile_GetCompletedChallengeCount
global function ChallengeTile_GetChallengeCount
global function ChallengeTile_HasMetaBlock
global function ChallengeTile_HasBRChallenges
global function ChallengeTile_HasNBRChallenges
global function ChallengeTile_IsCompleted

global function ChallengeTile_HasTrackedChallenges
global function ChallengeTile_UpdateFavoriteChallenge
global function ChallengeTile_GetNPPTile
global function ChallengeTile_GetActiveFeaturedTile
global function ChallengeTile_GetLobbyWidgetFeaturedChallenge
global function ChallengeTile_GetLobbyWidgetChallenges
global function ChallengeTile_AddLobbyWidgetHeaderEventHandlers
global function ChallengeTile_FindChallenge
global function ChallengeTile_GetTileByIndex


global function ChallengeTile_GetNPPChallengeCollection

global function ChallengeBlock_GetCompletedChallengeCount
global function ChallengeBlock_GetChallengeCount
global function ChallengeBlock_HasBRChallenges
global function ChallengeBlock_HasNBRChallenges

global function ChallengeBlock_HasTrackedChallenges
global function ChallengeBlock_GetLockReasons
global function ChallengeBlock_IsCompleted

global function Challenge_isNBRChallenge
global function Challenge_isBRChallenge
global function Challenge_HasNBRChallenge
global function Challenge_HasBRChallenge

#if DEV
global function ChallengeTile_PrintTiles
#endif

typedef ChallengeTileCategory int
typedef ChallengeBlockDisplayBehavior int
typedef ChallengeTileFlavsByCategory table< ChallengeTileCategory, array< ItemFlavor > >

global enum eChallengeBlockDisplayBehavior
{
	AUTO_SKIP_TO_BLOCK, 
	ALWAYS_DISPLAY 
}


global enum eChallengeBlockType
{
	DEFAULT, 
}


global enum eChallengeTileCategory
{
	TRACKED,
	DAILY,
	WEEKLY,
	EVENT,
	BEGINNER
}

global enum eChallengeBlockLockReasonState
{
	LOCKED,
	PROGRESSABLE,
	COMPLETED
}

global struct ChallengeTile_DeepLinkConfig
{
	string linkType 
	string link 
	string label 
	asset icon 
}

global struct ChallengeTile_LobbyWidgetConfig
{
	ItemFlavor ornull featuredChallenge
	asset headerImageBackground
	string headerLabel
	string challengeCategoryString
	string linkType 
	string link 
	bool showBPBadge
}

global struct ChallengeBlockLockReason
{
	string reason
	int    state
}

global struct ChallengeBlock
{
	int blockType 
	string title
	string rewards
	int startDate
	int endDate
	array<ItemFlavor> challenges

	
	bool locked
	array<ChallengeBlockLockReason> lockReasons

	void functionref( ChallengeBlock, entity ) ornull customBlockSort 

	
	bool isMetaBlock
}

typedef BlockSortFunc void functionref( ChallengeBlock, entity )

global struct ChallengeTile
{
	SettingsAssetGUID tileId
	ChallengeTileCategory tileCategory 
	ChallengeBlockDisplayBehavior challengeBlockDisplayBehavior 

	bool isEvergreen
	bool isFeatured
	int startDate
	int endDate
	string title
	string featuredRewards
	asset keyArt
	asset timerIcon

	array<ChallengeBlock> blocks
	int totalChallenges

	ChallengeTile_DeepLinkConfig& deepLinkConfig
	ChallengeTile_LobbyWidgetConfig& lobbyWidgetConfig
}


const string PLAYLIST_KILLSWITCH_VAR = "challenge_tiles_enabled"


enum eEventTileType
{
	CUSTOM,
	BUFFET,
	EVENT_SHOP
}


const string BLOCK_DAILIES_TITLE = "#BLOCK_DAILIES_TITLE"






struct FileStruct_ChallengeTiles
{
	table<ChallengeTileCategory, int> tileOrder
	array< ChallengeTile > activeTiles
}
FileStruct_ChallengeTiles& file

struct
{
	array<void functionref()> Callbacks_OnTileAdded
}callback

void function Sh_Challenge_Tiles_Init()
{
	FileStruct_ChallengeTiles localChallengeTileData
	file = localChallengeTileData

	
	const string defaultChallengeTileOrder = "TRACKED BEGINNER DAILY EVENT WEEKLY"
	string rawChallengeTileCategoricalOrder = GetPlaylistVarString( GetCurrentPlaylistName(), "challenge_tile_order", defaultChallengeTileOrder )
	array<ChallengeTileCategory> tileOrderList = ChallengeTileImport_ReadTileOrderFromString( rawChallengeTileCategoricalOrder )
	foreach ( int index, ChallengeTileCategory category in tileOrderList )
	{
		file.tileOrder[ category ] <- index
	}

	AddCallback_RegisterRootItemFlavors( ChallengeTileImport_RegisterItemFlavs )
}

bool function ChallengeTiles_IsEnabled()
{
	bool isEnabled = GetCurrentPlaylistVarBool( PLAYLIST_KILLSWITCH_VAR, true )
	return isEnabled
}

array<ChallengeTileCategory> function ChallengeTileImport_ReadTileOrderFromString( string rawString )
{
	array<string> categoryTokens = split( rawString, WHITESPACE_CHARACTERS )
	array<ChallengeTileCategory> categoryList

	foreach ( token in categoryTokens )
	{
		categoryList.append( ChallengeTileCategory_FromString( token.toupper() ) )
	}
	return categoryList
}

void function ChallengeTileImport_RegisterItemFlavs()
{
	
	ChallengeTileImport_FromBaseItemFlavs( "challengeTiles" )
	
}

void function ChallengeTileImport_FromBaseItemFlavs( string baseItemFlavArrayName )
{
	foreach ( asset tileAsset in GetBaseItemFlavorsFromArray( baseItemFlavArrayName ) )
	{
		if ( tileAsset == $"" )
		{
			continue
		}

		ItemFlavor ornull tileFlav = RegisterItemFlavorFromSettingsAsset( tileAsset )
		if ( tileFlav )
		{
			expect ItemFlavor( tileFlav )
			if ( GetGlobalSettingsBool( tileAsset, "useParentEventTimes" ) )
			{
				ItemFlavor parentFlavor = GetItemFlavorByAsset( GetGlobalSettingsAsset( tileAsset, "parentItemFlavor" ) )
				
				if ( ItemFlavor_GetType( parentFlavor ) == eItemType.battlepass )
				{
					table< string, string > metaData

					metaData[ "defaultStartTime" ] <- string(BattlePassV2_GetStartUnixTime( parentFlavor ))
					metaData[ "defaultFinishTime" ] <- string(BattlePassV2_GetFinishUnixTime( parentFlavor ))

					tileFlav.metaData = metaData
				}
				else
				{
					tileFlav.metaData = parentFlavor.metaData
				}
			}

			bool shouldImportAsset               = GetGlobalSettingsBool( tileAsset, "shouldImportCollection" )
			asset linkedChallengeCollectionAsset = GetGlobalSettingsAsset( tileAsset, "linkedChallengeCollection" )
			if ( shouldImportAsset && linkedChallengeCollectionAsset != $"" )
			{
				RegisterItemFlavorFromSettingsAsset( linkedChallengeCollectionAsset )
			}
		}
	}
}

bool function ChallengeTile_IsActive( ChallengeTile tile )
{
	int now = GetUnixTimestamp()

	bool hasStarted = now > tile.startDate
	bool hasEnded   = now >= tile.endDate

	int challengeCount = ChallengeTile_GetChallengeCount( tile ) 
	return challengeCount > 0 && hasStarted && !hasEnded
}

int function ChallengeTile_GetChallengeCount( ChallengeTile tile )
{
	int count = 0
	foreach ( ChallengeBlock block in tile.blocks )
	{
		count += block.challenges.len()
	}

	return count
}

bool function ChallengeTile_HasMetaBlock( ChallengeTile tile )
{
	foreach ( ChallengeBlock block in tile.blocks )
	{
		if ( block.isMetaBlock )
			return true
	}
	return false
}

struct TileSearchResult
{
	int tileIndex
	int blockIndex
	int challengeIndex
}

void function ChallengeTile_RemoveTileByGUID( SettingsAssetGUID guid )
{
	int targetIndex = -1
	foreach ( int index, ChallengeTile tile in file.activeTiles )
	{
		if ( tile.tileId == guid )
		{
			targetIndex = index
			break
		}
	}

	if ( targetIndex >= 0 )
	{
		ChallengeTile_RemoveTileAtIndex( targetIndex )
	}
}

void function ChallengeTile_RemoveTileAtIndex( int index )
{
	ChallengeTile tile = file.activeTiles.remove( index )
	ChallengeTile_OnTileRemoved( tile )
}

ChallengeTile function ChallengeTile_GetTileByIndex( int tileIndex )
{
	return file.activeTiles[ tileIndex ]
}

ChallengeBlock function ChallengeTile_GetBlockByIndex( int tileIndex, int blockIndex )
{
	return ChallengeTile_GetTileByIndex( tileIndex ).blocks[ blockIndex ]
}


array<TileSearchResult> function ChallengeTile_FindChallenge( SettingsAssetGUID challengeGUID )
{
	array<TileSearchResult> results
	foreach ( int tileIndex, ChallengeTile tile in ChallengeTile_GetActiveTiles() )
	{
		foreach ( int blockIndex, ChallengeBlock block in tile.blocks )
		{
			foreach ( int challengeIndex, ItemFlavor challenge in block.challenges )
			{
				if ( challenge.guid == challengeGUID )
				{
					TileSearchResult result
					result.tileIndex = tileIndex
					result.blockIndex = blockIndex
					result.challengeIndex = challengeIndex

					results.append( result )
				}
			}
		}
	}
	return results
}

array<TileSearchResult> function ChallengeTile_FindChallengeInTile( SettingsAssetGUID challengeGUID, ChallengeTile tile )
{
	array<TileSearchResult> results
	foreach ( int blockIndex, ChallengeBlock block in tile.blocks )
	{
		foreach ( int challengeIndex, ItemFlavor challenge in block.challenges )
		{
			if ( challenge.guid == challengeGUID )
			{
				TileSearchResult result
				result.tileIndex = -1
				result.blockIndex = blockIndex
				result.challengeIndex = challengeIndex

				results.append( result )
			}
		}
	}
	return results
}

bool function ChallengeTile_HasTrackedChallenges( ChallengeTile tile )
{
	foreach ( ChallengeBlock block in tile.blocks )
	{
		if ( ChallengeBlock_HasTrackedChallenges( block ) )
			return true
	}
	return false
}

void function ChallengeTile_InsertTile( ChallengeTile tile, int position = -1 )
{
	if ( position >= 0 )
	{
		file.activeTiles.insert( position, tile )
	}
	else
	{
		file.activeTiles.append( tile )
	}

	ChallengeTile_OnTileAdded( tile )
}

void function ChallengeTile_InsertBlock( int tileIndex, ChallengeBlock block, int position = -1 )
{
	ChallengeTile tile = ChallengeTile_GetTileByIndex( tileIndex )
	if ( position >= 0 )
	{
		tile.blocks.insert( position, block )
	}
	else 
	{
		position = tile.blocks.len()
		tile.blocks.append( block )
	}
	ChallengeTile_OnBlockAdded( tileIndex, position )
}

ChallengeBlock function ChallengeTile_RemoveBlock( int tileIndex, int blockIndex )
{
	ChallengeTile tile = ChallengeTile_GetTileByIndex( tileIndex )
	ChallengeBlock block = tile.blocks.remove( blockIndex )
	ChallengeTile_OnBlockRemoved( tileIndex, block )
	return block
}


void function ChallengeTile_InsertChallenge( int tileIndex, int blockIndex, ItemFlavor challenge, int position = -1 )
{
	ChallengeBlock block = ChallengeTile_GetBlockByIndex( tileIndex, blockIndex )
	if ( position == -1 )
	{
		block.challenges.append( challenge )
	}
	else
	{
		block.challenges.insert( position, challenge )
	}

	ChallengeTile_OnChallengeAdded( tileIndex, blockIndex, challenge.guid )
}


ItemFlavor ornull function ChallengeTile_RemoveChallenge( int tileIndex, int blockIndex, SettingsAssetGUID challengeGUID )
{
	ChallengeBlock block = ChallengeTile_GetBlockByIndex( tileIndex, blockIndex )
	foreach ( int index, ItemFlavor challengeFlav in block.challenges )
	{
		if ( challengeFlav.guid == challengeGUID )
		{
			ItemFlavor challenge = block.challenges.remove( index )

			ChallengeTile_OnChallengeRemoved( tileIndex, blockIndex, challenge.guid )
			return challenge
		}
	}
	return null
}

void function ChallengeTile_InsertFavoriteChallenge( SettingsAssetGUID challengeGUID )
{
	
	array<int> trackedTileIndexes = ChallengeTile_GetActiveTileIndexesByCategory( eChallengeTileCategory.TRACKED )



	if ( trackedTileIndexes.len() == 0 )
	{
		
		ChallengeTileFlavsByCategory tileFlavsByCategory = ChallengeTile_GetActiveTileFlavsByCategory()

		
		array<ChallengeTile> newTrackedTiles = TileBuild_TrackedChallenge( GetLocalClientPlayer(), tileFlavsByCategory[ eChallengeTileCategory.TRACKED ] )
		if ( newTrackedTiles.len() > 0 )
		{
			file.activeTiles.insert( 0, newTrackedTiles[0] ) 
		}
	}
	else
	{
		int trackedTileIndex = trackedTileIndexes[0]
		ChallengeTile trackedTile = ChallengeTile_GetTileByIndex( trackedTileIndex )
		
		ItemFlavor challenge = GetItemFlavorByGUID( challengeGUID )
		Assert( ItemFlavor_GetType( challenge ) == eItemType.challenge )
		ChallengeTile_InsertChallenge( trackedTileIndex, 0, challenge )
	}
}

void function ChallengeTile_RemoveFavoriteChallenge( SettingsAssetGUID challengeGUID )
{
	
	array<int> trackedTileIndexes = ChallengeTile_GetActiveTileIndexesByCategory( eChallengeTileCategory.TRACKED )

	int trackedTileIndex
	ChallengeTile trackedTile
	if ( trackedTileIndexes.len() == 0 )
	{
		return
	}
	else
	{
		trackedTileIndex = trackedTileIndexes[0]
	}

	trackedTile = ChallengeTile_GetTileByIndex( trackedTileIndex )
	
	ItemFlavor ornull removedChallenge = ChallengeTile_RemoveChallenge( trackedTileIndex, 0, challengeGUID )
}

void function ChallengeTile_UpdateFavoriteChallenge( SettingsAssetGUID challengeGUID, bool willFavorite )
{
	if ( willFavorite )
	{
		ChallengeTile_InsertFavoriteChallenge( challengeGUID )
	}
	else
	{
		ChallengeTile_RemoveFavoriteChallenge( challengeGUID )
	}
}

ChallengeTile ornull function ChallengeTile_GetNPPTile()
{
	array<int> nppTiles = ChallengeTile_GetActiveTileIndexesByCategory( eChallengeTileCategory.BEGINNER )
	Assert( nppTiles.len() <= 1 )
	if ( nppTiles.len() > 0 )
	{
		return ChallengeTile_GetTileByIndex( nppTiles[0] )
	}
	return null
}

array<ChallengeTile> function ChallengeTile_GetActiveFeaturedTiles()
{
	entity player = GetLocalClientPlayer()
	array<ChallengeTile> featuredTiles

	foreach( ChallengeTile tile in ChallengeTile_GetActiveTiles() )
	{
		if ( tile.isFeatured && !ChallengeTile_IsCompleted( tile, player ) )
		{
			featuredTiles.push( tile )
		}
	}
	Assert( featuredTiles.len() <= 1, "Only 1 concurrent active featured tile is currently supported!" )

	return featuredTiles
}


ChallengeTile ornull function ChallengeTile_GetActiveFeaturedTile()
{
	array<ChallengeTile> featuredTiles = ChallengeTile_GetActiveFeaturedTiles()
	if ( featuredTiles.len() > 0 )
	{
		return featuredTiles[ 0 ]
	}
	return null
}


ChallengeBlock ornull function ChallengeTile_GetLobbyWidgetFeaturedBlock( ChallengeTile tile )
{
	for( int blockIndex = tile.blocks.len() - 1; blockIndex >= 0; blockIndex-- )
	{
		if ( !tile.blocks[ blockIndex ].locked && !ChallengeBlock_IsCompleted( tile.blocks[ blockIndex ] ) )
		{
			return tile.blocks[ blockIndex ]
		}
	}

	return null
}

ItemFlavor ornull function ChallengeTile_GetLobbyWidgetFeaturedChallenge( ChallengeTile tile )
{
	entity player = GetLocalClientPlayer()

	ItemFlavor ornull featuredChallenge = tile.lobbyWidgetConfig.featuredChallenge
	if ( featuredChallenge != null )
	{
		expect ItemFlavor( featuredChallenge )

		if ( Challenge_IsAssigned( player, featuredChallenge ) )
		{
			return featuredChallenge
		}
	}
	return null
}

array<ItemFlavor> function ChallengeTile_GetLobbyWidgetChallenges( ChallengeTile tile, int maxChallenges )
{
	entity player = GetLocalClientPlayer()
	array<ItemFlavor> featuredChallenges

	ChallengeBlock ornull featuredBlock = ChallengeTile_GetLobbyWidgetFeaturedBlock( tile )
	ItemFlavor ornull featuredChallenge = ChallengeTile_GetLobbyWidgetFeaturedChallenge( tile )
	if ( featuredBlock != null )
	{
		expect ChallengeBlock( featuredBlock )
		array<ItemFlavor> blockChallenges = featuredBlock.challenges
		for ( int challengeIndex = 0; challengeIndex < blockChallenges.len() && featuredChallenges.len() < maxChallenges; challengeIndex++ )
		{
			ItemFlavor currentChallenge = blockChallenges[ challengeIndex ]

			
			if ( currentChallenge != featuredChallenge && !Challenge_IsMetaChallenge( currentChallenge ) )
			{
				featuredChallenges.push( currentChallenge )
			}
		}
	}
	return featuredChallenges
}


void function ChallengeTile_AddLobbyWidgetHeaderEventHandlers( ChallengeTile featuredTile, var mainElem, table<var, void functionref(var)> focusHandlerMap, table<var, void functionref(var)> clickHandlerMap )
{
	ItemFlavor ornull challenge = ChallengeTile_GetLobbyWidgetFeaturedChallenge( featuredTile )

	
	if ( challenge != null )
	{
		expect ItemFlavor( challenge )

		
		void functionref( var ) headerFocusHandler = ( void function( var button ) : () {
			EmitUISound( "ui_menu_focus" )
		} )
		Hud_AddEventHandler( mainElem, UIE_GET_FOCUS, headerFocusHandler )
		focusHandlerMap[ mainElem ] <- headerFocusHandler

		
		if ( featuredTile.lobbyWidgetConfig.linkType != "" )
		{
			void functionref( var ) headerClickHandler = ( void function( var button ) : ( featuredTile ) {
				OpenPromoLink( featuredTile.lobbyWidgetConfig.linkType, featuredTile.lobbyWidgetConfig.link )
			} )

			Hud_AddEventHandler( mainElem, UIE_CLICK, headerClickHandler )
			clickHandlerMap[ mainElem ] <- headerClickHandler
		}
	}
}


void function ChallengeTile_OnAllTilesRefreshed()
{
	foreach ( void functionref() cb in callback.Callbacks_OnTileAdded )
		cb()
}


void function ChallengeTile_OnTileAdded( ChallengeTile tile )
{

}


void function ChallengeTile_OnTileRemoved( ChallengeTile tile )
{

}


void function ChallengeTile_OnBlockAdded( int tileIndex, int blockIndex )
{

}


void function ChallengeTile_OnBlockRemoved( int tileIndex, ChallengeBlock block )
{
	ChallengeTile tile = ChallengeTile_GetTileByIndex( tileIndex )
	if ( ChallengeTile_GetChallengeCount( tile ) == 0 )
	{
		ChallengeTile_RemoveTileAtIndex( tileIndex )		
	}
}


void function ChallengeTile_OnChallengeAdded( int tileIndex, int blockIndex, SettingsAssetGUID challengeGUID )
{
	ChallengeBlock block = ChallengeTile_GetBlockByIndex( tileIndex, blockIndex )
	ChallengeBlock_Sort( block, GetLocalClientPlayer() )
}


void function ChallengeTile_OnChallengeRemoved( int tileIndex, int blockIndex, SettingsAssetGUID challengeGUID )
{
	ChallengeTile tile = ChallengeTile_GetTileByIndex( tileIndex )
	ChallengeBlock block = tile.blocks[ blockIndex ]
	if ( block.challenges.len() == 0 )
	{
		ChallengeTile_RemoveBlock( tileIndex, blockIndex )
	}
	else
	{
		ChallengeBlock_Sort( block, GetLocalClientPlayer() )
	}
}

void function AddCallback_OnChallengeTileAdded( void functionref() callbackFunc )
{
	if( !callback.Callbacks_OnTileAdded.contains( callbackFunc ) )
		callback.Callbacks_OnTileAdded.append( callbackFunc )
}

void function RemoveCallback_OnChallengeTileAdded( void functionref() callbackFunc )
{
	Assert( callback.Callbacks_OnTileAdded.contains( callbackFunc ), "No function with name " + string( callbackFunc ) + " was found in Callbacks_OnTileAdded" )
	callback.Callbacks_OnTileAdded.fastremovebyvalue( callbackFunc )
}


ChallengeCollection function ChallengeTile_GetNPPChallengeCollection()
{
	ChallengeCollection challengeCollection
	array<ItemFlavor> tileFlavs = ChallengeTileFlav_GetActiveTilesOfCategory( eChallengeTileCategory.BEGINNER )

	Assert( tileFlavs.len() <= 1, "Found Multiple NPP Challenge Tiles" )

	foreach ( tileFlav in tileFlavs )
	{
		challengeCollection = ChallengeTileFlav_GetLinkedCollection( tileFlav )
	}

	return challengeCollection
}

bool function ChallengeTile_HasBRChallenges( ChallengeTile tile )
{
	foreach ( ChallengeBlock block in tile.blocks )
	{
		if ( ChallengeBlock_HasBRChallenges( block ) )
			return true
	}
	return false
}

bool function ChallengeTile_HasNBRChallenges( ChallengeTile tile )
{
	foreach ( ChallengeBlock block in tile.blocks )
	{
		if ( ChallengeBlock_HasNBRChallenges( block ) )
			return true
	}
	return false
}

int function ChallengeTile_GetCompletedChallengeCount( ChallengeTile tile, entity player )
{
	array<ItemFlavor> challenges
	foreach ( int index, ChallengeBlock block in tile.blocks )
	{
		bool isNarrativeBlock = false
		if ( index == tile.blocks.len() - 1 )
		{
			foreach( challenge in block.challenges )
			{
				isNarrativeBlock = Challenge_IsNarrativeChallenge( challenge )
				break
			}
		}

		if ( !isNarrativeBlock )
			challenges.extend( block.challenges )
	}
	return GetCompletedChallengeCount( player, challenges )
}

bool function ChallengeTile_IsCompleted( ChallengeTile tile, entity player )
{
	foreach( ChallengeBlock block in tile.blocks )
	{
		if ( block.locked )
			return false
	}
	return ChallengeTile_GetCompletedChallengeCount( tile, player ) == ChallengeTile_GetChallengeCount( tile )
}



void function ChallengeBlock_Sort( ChallengeBlock block, entity player )
{
	BlockSortFunc sortFunc = block.customBlockSort != null ? expect BlockSortFunc( block.customBlockSort ) : ChallengeBlock_SortChallengesByProgress

	sortFunc( block, player )
}

void function ChallengeBlock_SortChallengesByProgress( ChallengeBlock block, entity player )
{
	array<ItemFlavor> metaChallenges
	array<ItemFlavor> narrativeChallenges_unfinished
	array<ItemFlavor> inProgress
	array<ItemFlavor> unstarted
	array<ItemFlavor> narrativeChallenges_finished
	array<ItemFlavor> finished

	
	while ( block.challenges.len() > 0 )
	{
		ItemFlavor challenge = block.challenges.pop()

		if ( !Challenge_IsAssigned( player, challenge ) )
		{
			continue
		}

		if ( Challenge_IsMetaChallenge( challenge ) )
		{
			metaChallenges.push( challenge)
			continue
		}

		if ( Challenge_IsNarrativeChallenge( challenge ) )
		{
			if ( Challenge_IsComplete( player, challenge ) )
			{
				narrativeChallenges_finished.push( challenge )
			}
			else
			{
				narrativeChallenges_unfinished.push( challenge )
			}
			continue
		}

		if ( Challenge_IsComplete( player, challenge ) )
		{
			finished.push( challenge )
			continue
		}

		if ( !Challenge_HasProgress( player, challenge ) )
		{
			unstarted.push( challenge )
		}
		else
		{
			inProgress.push( challenge )
		}
	}

	
	inProgress.sort( int function( ItemFlavor challengeA, ItemFlavor challengeB ) : ( player )
	{
		int currentTierA       = Challenge_GetCurrentTier( player, challengeA )
		int currentTierB       = Challenge_GetCurrentTier( player, challengeB )

		float percentProgressA = Challenge_GetProgressPercent( player, challengeA, currentTierA )
		float percentProgressB = Challenge_GetProgressPercent( player, challengeB, currentTierB )

		
		if ( Challenge_IsEitherOr( challengeA ) )
		{
			float percentProgressAltA = Challenge_GetProgressPercent( player, challengeA, currentTierA, true )
			if ( percentProgressAltA > percentProgressA )
			{
				percentProgressA = percentProgressAltA
			}
		}

		if ( Challenge_IsEitherOr( challengeB ) )
		{
			float percentProgressAltB = Challenge_GetProgressPercent( player, challengeB, currentTierB, true )
			if ( percentProgressAltB > percentProgressB )
			{
				percentProgressB = percentProgressAltB
			}
		}

		return ( percentProgressA >= percentProgressB ) ? -1 : 1
	})

	
	unstarted.sort( Challenge_SortSameProgressChallenges )
	finished.sort( Challenge_SortSameProgressChallenges )

	
	block.challenges.extend( metaChallenges )
	block.challenges.extend( narrativeChallenges_unfinished )
	block.challenges.extend( inProgress )
	block.challenges.extend( unstarted )
	block.challenges.extend( narrativeChallenges_finished )
	block.challenges.extend( finished )

	return
}

void function ChallengeBlock_SortNarrativeBlock( ChallengeBlock block, entity player )
{
	array<ItemFlavor> narrativeChallenges
	while ( block.challenges.len() > 0 )
	{
		ItemFlavor challenge = block.challenges.pop()

		if ( !Challenge_IsAssigned( player, challenge ) )
		{
			continue
		}

		
		if ( !Challenge_IsNarrativeChallenge( challenge ) )
		{
			continue
		}

		narrativeChallenges.push( challenge )
	}

	narrativeChallenges.sort( Narrative_CompareChallengeSortOrder )

	block.challenges.extend( narrativeChallenges )
}


int function ChallengeBlock_GetCompletedChallengeCount( ChallengeBlock block, entity player )
{
	return GetCompletedChallengeCount( player, block.challenges )
}

int function ChallengeBlock_GetChallengeCount( ChallengeBlock block )
{
	return block.challenges.len()
}

bool function ChallengeBlock_HasBRChallenges( ChallengeBlock block )
{
	foreach ( ItemFlavor challenge in block.challenges )
	{
		if ( Challenge_HasBRChallenge( challenge ) )
			return true
	}
	return false
}

bool function ChallengeBlock_HasNBRChallenges( ChallengeBlock block )
{
	foreach ( ItemFlavor challenge in block.challenges )
	{
		if ( Challenge_HasNBRChallenge( challenge ) )
			return true
	}
	return false
}

bool function Challenge_HasNBRChallenge( ItemFlavor challenge )
{
	if ( Challenge_IsEitherOr( challenge ) )
	{
		int gameMode = Challenge_GetGameMode( challenge, true )
		if ( (gameMode != eChallengeGameMode.BATTLE_ROYALE && gameMode != eChallengeGameMode.ANY ) && gameMode != eChallengeGameMode.NON_MODE )
			return true
	}
	int gameMode = Challenge_GetGameMode( challenge )
	return (gameMode != eChallengeGameMode.BATTLE_ROYALE && gameMode != eChallengeGameMode.ANY ) && gameMode != eChallengeGameMode.NON_MODE
}

bool function Challenge_HasBRChallenge( ItemFlavor challenge )
{
	if ( Challenge_IsEitherOr( challenge ) )
	{
		int gameMode = Challenge_GetGameMode( challenge, true )
		if ( gameMode == eChallengeGameMode.BATTLE_ROYALE )
			return true
	}
	int gameMode = Challenge_GetGameMode( challenge )
	return gameMode == eChallengeGameMode.BATTLE_ROYALE
}

bool function Challenge_isNBRChallenge( ItemFlavor challenge, bool isAlt = false )
{
	int gameMode = Challenge_GetGameMode( challenge, isAlt )
	return (gameMode != eChallengeGameMode.BATTLE_ROYALE && gameMode != eChallengeGameMode.ANY ) && gameMode != eChallengeGameMode.NON_MODE
}

bool function Challenge_isBRChallenge( ItemFlavor challenge, bool isAlt = false)
{
	return Challenge_GetGameMode( challenge, isAlt ) == eChallengeGameMode.BATTLE_ROYALE
}


bool function ChallengeBlock_HasTrackedChallenges( ChallengeBlock block )
{
	foreach ( ItemFlavor challenge in block.challenges )
	{
		if ( IsFavoriteChallenge( challenge ) )
			return true
	}
	return false
}

array<ChallengeBlockLockReason> function ChallengeBlock_GetLockReasons( ChallengeBlock block )
{
	return block.lockReasons
}

bool function ChallengeBlock_IsCompleted( ChallengeBlock block )
{
	return ChallengeBlock_GetCompletedChallengeCount( block, GetLocalClientPlayer() ) >= ChallengeBlock_GetChallengeCount( block )
}



array<ChallengeTile> function ChallengeTile_GenerateModels()
{
	array<ChallengeTile> challengeTiles

	

	if ( ChallengeTiles_IsEnabled() )
	{
		entity player = GetLocalClientPlayer()
		Assert( player == GetLocalClientPlayer() )

		ChallengeTileFlavsByCategory tileFlavsByCategory = ChallengeTile_GetActiveTileFlavsByCategory()

		
		challengeTiles.extend( TileBuild_TrackedChallenge( player, tileFlavsByCategory[ eChallengeTileCategory.TRACKED ] ) )

		

		if ( NPP_GetIsActiveNPP ( GetLocalClientPlayer() ) )

			challengeTiles.extend( TileBuild_Beginner( player, tileFlavsByCategory[ eChallengeTileCategory.BEGINNER ] ) )

		
		challengeTiles.extend( TileBuild_Dailies( player, tileFlavsByCategory ) )

		
		challengeTiles.extend( TileBuild_Events( player, tileFlavsByCategory[ eChallengeTileCategory.EVENT ] ) )

		
		challengeTiles.extend( TileBuild_Weeklies( player, tileFlavsByCategory[ eChallengeTileCategory.WEEKLY ] ) )
	}



	printf( "%s: Challenge Tiles:\n", FUNC_NAME() )
	foreach ( tile in challengeTiles )
	{
		printf( "%s:\t: category: %i | guid: %i | numChallenges: %i ", FUNC_NAME(), tile.tileCategory, tile.tileId, ChallengeTile_GetChallengeCount( tile ) )
	}
	return challengeTiles
}

array<ChallengeTile> function ChallengeTile_GetActiveTiles()
{
	return file.activeTiles
}


array<ChallengeTile> function ChallengeTile_GetActiveTilesSorted()
{
	array<ChallengeTile> sortedTiles = clone file.activeTiles
	sortedTiles.sort( ChallengeTile_SortTiles )
	return sortedTiles
}


ChallengeTile function ChallengeTile_GetActiveTileByGUID( SettingsAssetGUID guid )
{

	foreach( tile in file.activeTiles )
	{
		if ( tile.tileId == guid )
		{
			return tile
		}
	}

	Assert( false, format( "Attempted to call %s for inactive tile with id %i", FUNC_NAME(), guid ) )
	unreachable
}

array<int> function ChallengeTile_GetActiveTileIndexesByCategory( ChallengeTileCategory tileCategory )
{
	array<int> tileIndexes
	foreach ( int index, ChallengeTile tile in ChallengeTile_GetActiveTiles() )
	{
		if ( tile.tileCategory == tileCategory )
		{
			tileIndexes.append( index )
		}
	}
	return tileIndexes
}

array<ChallengeTile> function ChallengeTile_GetActiveTilesByCategory( ChallengeTileCategory tileCategory )
{
	array<ChallengeTile> tiles
	foreach ( ChallengeTile tile in ChallengeTile_GetActiveTiles() )
	{
		if ( tile.tileCategory == tileCategory )
		{
			tiles.append( tile )
		}
	}
	return tiles
}

array<ChallengeBlock> function ChallengeTile_GetActiveBlocks( ChallengeTile tile )
{
	return tile.blocks
}



void function ChallengeTile_RefreshTiles()
{
	if ( !IsLobby() )
	{
		return
	}

	file.activeTiles.clear()
	file.activeTiles = ChallengeTile_GenerateModels()

	foreach ( tile in file.activeTiles )
	{
		ChallengeTile_SortTile( GetLocalClientPlayer(), tile )
	}

	ChallengeTile_OnAllTilesRefreshed()
}



ChallengeTileFlavsByCategory function ChallengeTile_GetActiveTileFlavsByCategory()
{
	array<ItemFlavor> registeredTileFlavs = GetAllItemFlavorsOfType( eItemType.challenge_tile )
	ChallengeTileFlavsByCategory tilesByCategory = {}

	
	foreach ( ChallengeTileCategory category in eChallengeTileCategory )
	{
		tilesByCategory[ category ] <- []
	}

	
	int now = GetUnixTimestamp()
	foreach ( ItemFlavor tileFlav in registeredTileFlavs )
	{
		ChallengeTileCategory category = ChallengeTileFlav_GetCategory( tileFlav )
		if ( ChallengeTileFlav_IsEvergreen( tileFlav ) || CalEvent_IsActive( tileFlav, now ) )
		{
			
			if ( category != eChallengeTileCategory.EVENT && tilesByCategory[ category ].len() >= 1 )
			{
				Assert( false, format( "There should only be 1 kind of active tile with category %i. Existing: %i, Upcoming: %i", category, tilesByCategory[ category ][0].guid, tileFlav.guid ) )
			}
			else
			{
				tilesByCategory[ category ].append( tileFlav )
			}
		}
	}
	return tilesByCategory
}

array< ItemFlavor > function ChallengeTileFlav_GetActiveTilesOfCategory( ChallengeTileCategory category )
{
	return ChallengeTile_GetActiveTileFlavsByCategory()[ category ]
}


ChallengeTileCategory function ChallengeTileCategory_FromString( string enumKey )
{
	Assert( enumKey in eChallengeTileCategory, "Invalid eChallengeTileCategory enum value: " + enumKey )
	return eChallengeTileCategory[enumKey]
}
ChallengeTileCategory function ChallengeTileFlav_GetCategory( ItemFlavor itemFlav )
{
	Assert( ItemFlavor_GetType( itemFlav ) == eItemType.challenge_tile )
	Assert( IsItemFlavorStructValid( itemFlav.guid, eValidation.ASSERT ) )
	ChallengeTileCategory category = ChallengeTileCategory_FromString( GetGlobalSettingsString( ItemFlavor_GetAsset( itemFlav ), "challengeTileCategory" ) )
	return category
}

ChallengeCollection function ChallengeTileFlav_GetLinkedCollection( ItemFlavor tileFlav )
{
	Assert( ItemFlavor_GetType( tileFlav ) == eItemType.challenge_tile )
	ChallengeTileCategory tileCategory = ChallengeTileFlav_GetCategory( tileFlav )
	asset linkedCollectionAsset        = GetGlobalSettingsAsset( ItemFlavor_GetAsset( tileFlav ), "linkedChallengeCollection" )
	Assert( linkedCollectionAsset != $"" )

	ItemFlavor linkedCollection = GetItemFlavorByAsset(linkedCollectionAsset)
	ChallengeCollection collection = ChallengeCollection_GetByGUID( linkedCollection.guid )
	return collection
}

bool function ChallengeTileFlav_IsEvergreen( ItemFlavor tileFlav )
{
	return GetGlobalSettingsBool( ItemFlavor_GetAsset( tileFlav ), "isEvergreen" )
}

array< ItemFlavor > function ChallengeTileFlav_GetAllLinkedCollectionChallenges( ItemFlavor tileFlav )
{
	Assert( ItemFlavor_GetType( tileFlav ) == eItemType.challenge_tile )
	asset tileAsset = ItemFlavor_GetAsset( tileFlav )
	ChallengeTileCategory category = ChallengeTileFlav_GetCategory( tileFlav )

	
	bool hasLinkedCollection = category == eChallengeTileCategory.BEGINNER || (category == eChallengeTileCategory.EVENT && GetGlobalSettingsInt( tileAsset, "eventTileType" ) == eEventTileType.CUSTOM )
	if ( !hasLinkedCollection )
	{
		return []
	}

	ChallengeCollection collection = ChallengeTileFlav_GetLinkedCollection( tileFlav )
	return ChallengeCollection_GetAllChallenges( collection )
}

bool function ChallengeTile_HasDeepLink( ChallengeTile tile )
{
	return tile.deepLinkConfig.linkType != ""
}



int function ChallengeTile_SortTiles( ChallengeTile tileA, ChallengeTile tileB )
{
	entity player = GetLocalClientPlayer()

	
	bool tileAComplete = ChallengeTile_IsCompleted( tileA, player )
	bool tileBComplete = ChallengeTile_IsCompleted( tileB, player )

	if ( tileAComplete && !tileBComplete )
		return 1
	else if ( !tileAComplete && tileBComplete )
		return -1

	
	ChallengeTileCategory tileCategoryA = tileA.tileCategory
	ChallengeTileCategory tileCategoryB = tileB.tileCategory
	if ( file.tileOrder[ tileCategoryA ] < file.tileOrder[ tileCategoryB ] )
		return -1
	else if ( file.tileOrder[ tileCategoryA ] > file.tileOrder[ tileCategoryB ] )
		return 1

	
	if( tileA.endDate < tileB.endDate )
		return -1
	else if( tileA.endDate > tileB.endDate )
		return 1

	return 0
}



void function ChallengeTile_SortTile( entity player, ChallengeTile tile )
{
	foreach ( block in tile.blocks )
	{
		ChallengeBlock_Sort( block, player )
	}
}


ChallengeTile function TileBuild_FromItemFlav( ItemFlavor itemFlav )
{
	ChallengeTile challengeTile
	asset tileAsset = ItemFlavor_GetAsset( itemFlav )
	challengeTile.tileCategory = ChallengeTileFlav_GetCategory( itemFlav )

	challengeTile.tileId = itemFlav.guid
	challengeTile.isEvergreen = ChallengeTileFlav_IsEvergreen( itemFlav )
	challengeTile.startDate = CalEvent_GetStartUnixTime( itemFlav )
	challengeTile.endDate = CalEvent_GetFinishUnixTime( itemFlav )

	challengeTile.title = ItemFlavor_GetLongName( itemFlav )

	challengeTile.featuredRewards = GetGlobalSettingsString( tileAsset, "featuredRewards" )
	challengeTile.keyArt = GetGlobalSettingsAsset( tileAsset, "keyArt" )
	challengeTile.timerIcon = GetGlobalSettingsAsset( tileAsset, "timerIcon" )
	challengeTile.challengeBlockDisplayBehavior = eChallengeBlockDisplayBehavior.AUTO_SKIP_TO_BLOCK 
	challengeTile.blocks = []
	challengeTile.deepLinkConfig = TileBuild_DeepLinkConfig( itemFlav )

	challengeTile.isFeatured = GetGlobalSettingsBool( ItemFlavor_GetAsset( itemFlav ), "isFeatured" )
	challengeTile.lobbyWidgetConfig = TileBuild_LobbyWidgetConfig( itemFlav )
	return challengeTile
}

ChallengeTile_DeepLinkConfig function TileBuild_DeepLinkConfig( ItemFlavor itemFlav )
{
	asset tileAsset = ItemFlavor_GetAsset( itemFlav )
	ChallengeTile_DeepLinkConfig deepLinkConfig
	deepLinkConfig.linkType = GetGlobalSettingsString( tileAsset, "tileLinkType" )
	deepLinkConfig.link     = GetGlobalSettingsString( tileAsset, "tileLink" )
	deepLinkConfig.label    = GetGlobalSettingsString( tileAsset, "tileLinkLabel" )
	deepLinkConfig.icon     = GetGlobalSettingsAsset( tileAsset, "linkIcon" )

	return deepLinkConfig
}

ChallengeTile_LobbyWidgetConfig function TileBuild_LobbyWidgetConfig( ItemFlavor itemFlav )
{
	asset tileAsset = ItemFlavor_GetAsset( itemFlav )
	ChallengeTile_LobbyWidgetConfig lobbyWidgetConfig

	asset featuredChallengeAsset = GetGlobalSettingsAsset( tileAsset, "widget_featuredChallenge" )
	if ( featuredChallengeAsset != $"" && IsValidItemFlavorSettingsAsset( featuredChallengeAsset ) )
	{
		lobbyWidgetConfig.featuredChallenge = GetItemFlavorByAsset( featuredChallengeAsset )
	}

	lobbyWidgetConfig.headerImageBackground   = GetGlobalSettingsAsset( tileAsset, "widget_headerImageBackground" )
	lobbyWidgetConfig.headerLabel             = GetGlobalSettingsString( tileAsset, "widget_headerLabel" )
	lobbyWidgetConfig.challengeCategoryString = GetGlobalSettingsString( tileAsset, "widget_challengeCategoryString" )
	lobbyWidgetConfig.linkType                = GetGlobalSettingsString( tileAsset, "widget_deepLinkType" )
	lobbyWidgetConfig.link                    = GetGlobalSettingsString( tileAsset, "widget_deepLink" )
	lobbyWidgetConfig.showBPBadge             = GetGlobalSettingsBool( tileAsset, "widget_showBPBadge" )

	return lobbyWidgetConfig
}


array<ChallengeTile> function TileBuild_TrackedChallenge( entity player, array<ItemFlavor> tileFlavsOfCategory )
{
	array<ChallengeTile> tiles
	array<ItemFlavor> trackedChallenges = GetFavoriteChallenges( player )

	
	if ( trackedChallenges.len() == 0 )
	{
		return tiles
	}

	foreach ( ItemFlavor flav in tileFlavsOfCategory )
	{
		ChallengeTile tile = TileBuild_FromItemFlav( flav )

		ChallengeBlock block = BlockBuild_Default()
		block.title = "#CATEGORY_FAVORITES"
		block.challenges = trackedChallenges
		tile.blocks.append( block )
		tiles.append( tile )
	}

	return tiles
}



array<ChallengeTile> function TileBuild_Beginner( entity player, array<ItemFlavor> tileFlavsOfCategory )
{
	array<ChallengeTile> tiles


	array<ItemFlavor> beginnerChallenges

	foreach ( ItemFlavor flav in tileFlavsOfCategory )
	{
		ChallengeTile tile = TileBuild_FromItemFlav( flav )

		ChallengeCollection collection = ChallengeTileFlav_GetLinkedCollection( flav )
		tile = TileBuild_ExtendFromCollection( tile, collection )
		foreach( block in tile.blocks )
		{
			tile.totalChallenges += block.challenges.len()
		}

		tiles.append( tile )
	}


	return tiles
}



array<ChallengeTile> function TileBuild_Dailies( entity player, ChallengeTileFlavsByCategory tileFlavsByCategory )
{
	array<ItemFlavor> dailyTileFlavs = tileFlavsByCategory[ eChallengeTileCategory.DAILY ]
	array<ChallengeTile> tiles
	int dailyExpirationTime = Challenge_GetDailyExpirationTimeWithOffset( player )
	ItemFlavor ornull activeBattlePass = GetActiveBattlePass()
	foreach ( ItemFlavor flav in dailyTileFlavs )
	{
		ChallengeTile tile = TileBuild_FromItemFlav( flav )

		
		array<ChallengeBlock> eventDailies = BlockBuild_EventDailies( player, tileFlavsByCategory[ eChallengeTileCategory.EVENT ] )
		tile.blocks.extend( eventDailies )
		
		ChallengeBlock dailiesBlock = BlockBuild_Default()
		array<ItemFlavor> currentDailies = GetAssignedChallengesByTimeSpan( player, eChallengeTimeSpanKind.DAILY )
		dailiesBlock.challenges = currentDailies
		dailiesBlock.title = BLOCK_DAILIES_TITLE
		dailiesBlock.endDate = dailyExpirationTime
		tile.blocks.append( dailiesBlock )

		
		ChallengeBlock repeatableBlock = BlockBuild_Default()
		array<ItemFlavor> repeatableChallenges
		if ( activeBattlePass != null )
		{
			expect ItemFlavor( activeBattlePass )
			ItemFlavor ornull recurringStarChallenge = GetBattlePassRecurringStarChallenge( activeBattlePass )
			if ( recurringStarChallenge != null )
			{
				repeatableChallenges.append( expect ItemFlavor( recurringStarChallenge ) )
			}

			ItemFlavor ornull grindlordChallenge = GetBattlePassRecurringGrindlordChallenge( activeBattlePass )
			if ( grindlordChallenge != null )
			{
				repeatableChallenges.append( expect ItemFlavor( grindlordChallenge ) )
			}
		}

		repeatableBlock.challenges = repeatableChallenges
		repeatableBlock.title = "#BLOCK_REPEATABLE_TITLE"
		tile.blocks.append( repeatableBlock )

		
		tile.totalChallenges += repeatableChallenges.len() 
		tile.totalChallenges += currentDailies.len() 
		foreach( eventDailyblock in eventDailies )
		{
			tile.totalChallenges += eventDailyblock.challenges.len()
		}
		tiles.append( tile )
	}
	return tiles
}



array<ChallengeTile> function TileBuild_Events( entity player, array<ItemFlavor> tileFlavsOfCategory )
{
	array<ChallengeTile> tiles
	int now = GetUnixTimestamp()

	foreach ( ItemFlavor flav in tileFlavsOfCategory )
	{
		ChallengeTile tile = TileBuild_FromItemFlav( flav )
		asset tileAsset = ItemFlavor_GetAsset( flav )
		int eventTileType = GetGlobalSettingsInt( tileAsset, "eventTileType" )

		switch( eventTileType )
		{
			case eEventTileType.BUFFET:
				asset buffetEventAsset = GetGlobalSettingsAsset( tileAsset, "linkedBuffetEvent" )
				Assert( buffetEventAsset != $"", format( "Tile Flav %i has an invalid a linked Buffet Event!", flav.guid ) )
				ItemFlavor buffetEventFlav = GetItemFlavorByAsset( buffetEventAsset )
				if ( !CalEvent_IsActive( buffetEventFlav, now ) )
				{
					continue
				}
				
				tile.title = ItemFlavor_GetLongName( buffetEventFlav )

				
				tile.blocks.extend( BlockBuild_BuffetEventDailies( buffetEventFlav ) )

				break
			case eEventTileType.EVENT_SHOP:
				asset eventShopAsset = GetGlobalSettingsAsset( tileAsset, "linkedEventShop" )
				Assert( eventShopAsset != $"", format( "Tile Flav %i has an invalid a linked Event Shop!", flav.guid ) )
				ItemFlavor eventShopFlav = GetItemFlavorByAsset( eventShopAsset )
				if ( !CalEvent_IsActive( eventShopFlav, now ) )
				{
					continue
				}
				
				tile.title = ItemFlavor_GetLongName( eventShopFlav )

				
				tile.blocks.extend( BlockBuild_EventShopDailies( player, eventShopFlav ) )
				
				tile.blocks.extend( BlockBuild_EventShopLongChallenges( player, eventShopFlav ) )

				break
			
			case eEventTileType.CUSTOM:
				ChallengeCollection collection = ChallengeTileFlav_GetLinkedCollection( flav )
				tile = TileBuild_ExtendFromCollection( tile, collection )
				break
			default:
		}

		foreach( block in tile.blocks )
		{
			tile.totalChallenges += block.challenges.len()
		}
		tiles.append( tile )
	}

	return tiles
}



ChallengeTile function TileBuild_ExtendFromCollection( ChallengeTile tile, ChallengeCollection collection)
{
	array<ChallengeBlock> blocks = BlockBuild_FromChallengeCollection( collection )

	
	ItemFlavor ornull metaChallenge = collection.metaChallenge
	if ( metaChallenge != null )
	{
		expect ItemFlavor( metaChallenge )
		if ( Challenge_GetRewards( metaChallenge, 0 ).flavors.len() > 0 )
		{
			tile.blocks.append( BlockBuild_MetaBlock( metaChallenge ) )
		}
	}

	tile.blocks.extend( blocks )
	return tile
}



array<ChallengeTile> function TileBuild_Weeklies( entity player, array<ItemFlavor> tileFlavsOfCategory )
{
	array<ChallengeTile> tiles

	
	ItemFlavor ornull activePass = GetActiveBattlePass()
	if ( activePass == null )
	{
		return tiles
	}

	expect ItemFlavor( activePass )
	int maxWeeks = GetNumBattlePassChallengesWeeks( activePass )

	foreach ( ItemFlavor flav in tileFlavsOfCategory )
	{
		ChallengeTile tile = TileBuild_FromItemFlav( flav )

		array<ChallengeBlock> weeklyBlocks = []
		
		Challenge_IterateAssignedWeeklyChallenges( player, void function( int weekIndex, int groupIndex, array<ItemFlavor> challenges ) : ( weeklyBlocks )
			{
				if ( challenges.len() > 0 )
				{
					ChallengeBlock block = BlockBuild_Default()
					block.challenges = challenges
					block.title = Localize( "#CHALLENGE_GROUP_WEEKLY", weekIndex + 1 )
					weeklyBlocks.append( block )
				}
			}
		)

		
		foreach ( index, block in weeklyBlocks )
		{
			int weekNumber = index + 1

			ItemFlavor ornull narrativeChallenge = Narrative_FindActiveWeeklyChallenge( weekNumber )
			if ( narrativeChallenge != null )
			{
				expect ItemFlavor( narrativeChallenge )
				block.challenges.push( narrativeChallenge )
			}
		}

		
		int numAssignedWeeks = weeklyBlocks.len()
		int remainingWeeks   = maxWeeks - numAssignedWeeks
		for( int weekIndex = 0; weekIndex < remainingWeeks; weekIndex++ )
		{
			int visibleWeekIndex = numAssignedWeeks + weekIndex + 1
			int revealTime       = GetCurrentBattlePassWeekExpirationTime() + ( SECONDS_PER_WEEK * weekIndex )

			ChallengeBlock lockedWeekBlock = BlockBuild_Default()
			lockedWeekBlock.title = Localize( "#CHALLENGE_GROUP_WEEKLY", visibleWeekIndex )
			lockedWeekBlock.locked = true
			lockedWeekBlock.startDate = revealTime
			weeklyBlocks.append( lockedWeekBlock )
		}

		
		tile.blocks.extend( weeklyBlocks )

		array<ChallengeBlock> summaryblocks =  BlockBuild_NarrativeSummaryBlock()
		tile.blocks.extend( summaryblocks )

		
		ItemFlavor ornull activeBattlePass = GetActiveBattlePass()
		if ( activeBattlePass != null )
		{
			expect ItemFlavor( activeBattlePass )
			int narrativeChallengeCount = 0
			for ( int week = 0; week < GetNumBattlePassChallengesWeeks( activeBattlePass ); week++ )
			{
				ItemFlavor ornull narrativeChallenge = Narrative_FindActiveWeeklyChallenge( week )
				if ( narrativeChallenge != null )
					narrativeChallengeCount++
			}
			tile.totalChallenges = GetNumBattlePassChallenges( activeBattlePass ) + narrativeChallengeCount
		}

		if ( tile.blocks.len() > 0 )
		{
			tiles.append( tile )
		}
	}

	return tiles
}



ChallengeBlock function BlockBuild_Default()
{
	ChallengeBlock block
	block.challenges = []
	block.blockType = eChallengeBlockType.DEFAULT
	block.title = ""
	block.rewards = ""
	block.startDate = UNIX_TIME_FALLBACK_1970
	block.endDate = UNIX_TIME_FALLBACK_2038
	block.isMetaBlock = false
	return block
}



array<ChallengeBlock> function BlockBuild_FromChallengeCollection( ChallengeCollection collection )
{
	array<ChallengeBlock> blocks
	int now = GetUnixTimestamp()
	entity player = GetLocalClientPlayer()

	ChallengeBlock ornull prevBlock = null
	foreach ( ChallengeSet set in collection.challengeSets )
	{
		ChallengeBlock block = BlockBuild_FromChallengeSet( set )

		

		
		

		
		int bestTime = ChallengeCollection_IsEvergreen( collection ) ? block.startDate : CalEvent_GetStartUnixTime( collection.itemFlav )
		if ( collection.hasGlobalTimestamps )
			bestTime = set.globalUnlockTimetamp

		if ( collection.hasPersonalTimestamps )
		{
			int personalTimer = ChallengeSet_GetPersonalTimerForPlayer( GetLocalClientPlayer(), set )
			if ( personalTimer > bestTime )
				bestTime = personalTimer
		}

		
		if ( bestTime > now )
		{
			block.startDate = bestTime
			block.locked = true
		}

		
		if ( set.requiresPriorSetMetaCompletion && set.prevLinkInChain != null )
		{
			ChallengeSet ornull prevSet = set.prevLinkInChain
			expect ChallengeSet( prevSet )
			ChallengeBlockLockReason lockReason

			int minReqToUnlock     = ChallengeSet_GetMinimumNumberOfChallengesCompletedForUnlock( player, prevSet )
			string prevTitle       = Localize( ItemFlavor_GetLongName( prevSet.itemFlav ) )
			lockReason.reason      = Localize( "#CHALLENGE_LOCK_REASON_COMPLETION", minReqToUnlock, prevTitle )

			if ( !ChallengeSet_MeetsUnlockCompletionRequirements( player, prevSet ) )
			{
				Assert( prevBlock != null )
				expect ChallengeBlock( prevBlock )
				lockReason.state = prevBlock.locked ? eChallengeBlockLockReasonState.LOCKED : eChallengeBlockLockReasonState.PROGRESSABLE
				block.locked      = true
			}
			else
			{
				lockReason.state  = eChallengeBlockLockReasonState.COMPLETED
			}

			block.lockReasons.append( lockReason )
		}

		if ( !block.locked )
			block.endDate = ChallengeCollection_GetEndTime( player, collection )

		prevBlock = block
		blocks.append( block )
	}

	return blocks
}



ChallengeBlock function BlockBuild_FromChallengeSet( ChallengeSet set )
{
	ChallengeBlock block = BlockBuild_Default()

	
	ItemFlavor ornull metaChallenge = set.metaChallenge
	if ( metaChallenge != null )
	{
		expect ItemFlavor( metaChallenge )
		if ( Challenge_GetRewards( metaChallenge, 0 ).flavors.len() > 0 )
		{
			block.challenges.push( metaChallenge )
		}
	}

	block.challenges.extend( set.challenges )
	block.blockType = eChallengeBlockType.DEFAULT 
	block.title = ItemFlavor_GetLongName( set.itemFlav )
	block.rewards = ""
	return block
}



ChallengeBlock function BlockBuild_FromCalEvent( ItemFlavor eventFlav )
{
	ChallengeBlock block = BlockBuild_Default()
	block.startDate  = CalEvent_GetStartUnixTime( eventFlav )
	block.endDate    = CalEvent_GetFinishUnixTime( eventFlav )
	block.title      = ItemFlavor_GetLongName( eventFlav )
	block.blockType  = eChallengeBlockType.DEFAULT

	
	
	return block
}



array<ChallengeBlock> function BlockBuild_BuffetEventDailies( ItemFlavor buffetEventFlav, string blockTitleOverride = "" )
{
	array<ChallengeBlock> blocks

	BuffetEventModesAndChallengesData buffetEventData = BuffetEvent_GetModesAndChallengesData( buffetEventFlav )
	
	ChallengeBlock eventDailies = BlockBuild_FromCalEvent( buffetEventFlav )
	eventDailies.challenges = clone buffetEventData.dailyChallenges
	eventDailies.title = blockTitleOverride != "" ? blockTitleOverride : BlockBuild_LocalizeDailyBlockTitle( ItemFlavor_GetLongName( buffetEventFlav ) )
	blocks.append( eventDailies )

	return blocks
}




ItemFlavor ornull function BlockBuild_ValidateEventShop( ItemFlavor eventShopFlav )
{
	Assert( ItemFlavor_GetType( eventShopFlav ) == eItemType.calevent_event_shop )

	
	if ( !CalEvent_IsActive( eventShopFlav, GetUnixTimestamp() ) )
	{
		return null
	}

	ItemFlavor ornull currentEventShop = EventShop_GetCurrentActiveEventShop()

	
	if ( currentEventShop == null )
	{
		Assert( false, "No active event shop!" )
		return null
	}
	expect ItemFlavor(currentEventShop)

	if ( currentEventShop.guid != eventShopFlav.guid )
	{
		Assert( false, format( "Active event shop '%i' is not the same as linked event shop '%i'!", currentEventShop.guid, eventShopFlav.guid ) )
		return null
	}

	return eventShopFlav
}




array<ChallengeBlock> function BlockBuild_CombinedFromEventShop( entity player, ItemFlavor eventFlav )
{
	array<ChallengeBlock> blocks
	
	ItemFlavor ornull currentEventShop = BlockBuild_ValidateEventShop( eventFlav )
	if ( currentEventShop == null )
	{
		return blocks
	}

	EventShopData eventShopData = EventShop_GetEventShopData( eventFlav )

	ChallengeBlock eventDailies = BlockBuild_FromCalEvent( eventFlav )

	
	eventDailies.challenges.extend( GetAssignedChallengesByTimeSpan( player, eChallengeTimeSpanKind.EVENTSHOP_DAILY_CHALLENGE, -1, currentEventShop ) )
	eventDailies.challenges.extend( GetAssignedChallengesByTimeSpan( player, eChallengeTimeSpanKind.EVENTSHOP_EVENT_CHALLENGE, -1, currentEventShop ) )
	blocks.append( eventDailies )

	return blocks
}



array<ChallengeBlock> function BlockBuild_EventShopLongChallenges( entity player, ItemFlavor eventFlav )
{
	array<ChallengeBlock> blocks
	
	ItemFlavor ornull currentEventShop = BlockBuild_ValidateEventShop( eventFlav )
	if ( currentEventShop == null )
	{
		return blocks
	}

	
	array<ItemFlavor> challenges = GetAssignedChallengesByTimeSpan( player, eChallengeTimeSpanKind.EVENTSHOP_EVENT_CHALLENGE, -1, eventFlav )
	if ( challenges.len() == 0 )
	{
		return blocks
	}

	ChallengeBlock block = BlockBuild_FromCalEvent( eventFlav )
	EventShopData eventShopData = EventShop_GetEventShopData( eventFlav )
	block.challenges = challenges
	blocks.append( block )

	return blocks
}



array<ChallengeBlock> function BlockBuild_EventShopDailies( entity player, ItemFlavor eventFlav, string blockTitleOverride = "" )
{
	array<ChallengeBlock> blocks
	
	ItemFlavor ornull currentEventShop = BlockBuild_ValidateEventShop( eventFlav )
	if ( currentEventShop == null )
	{
		return blocks
	}

	
	array<ItemFlavor> challenges = GetAssignedChallengesByTimeSpan( player, eChallengeTimeSpanKind.EVENTSHOP_DAILY_CHALLENGE, -1, eventFlav )
	if ( challenges.len() == 0 )
	{
		return blocks
	}

	ChallengeBlock eventDailies = BlockBuild_FromCalEvent( eventFlav )
	EventShopData eventShopData = EventShop_GetEventShopData( eventFlav )
	eventDailies.challenges = challenges
	eventDailies.title = blockTitleOverride != "" ? blockTitleOverride : BlockBuild_LocalizeDailyBlockTitle( ItemFlavor_GetLongName( eventFlav ) )
	eventDailies.endDate = Challenge_GetDailyExpirationTimeWithOffset( player )
	blocks.append( eventDailies )

	return blocks
}



array<ChallengeBlock> function BlockBuild_EventDailies( entity player, array<ItemFlavor> tileFlavsOfCategory )
{
	array<ChallengeBlock> blocks
	int now = GetUnixTimestamp()

	
	foreach ( ItemFlavor flav in tileFlavsOfCategory )
	{
		asset tileAsset = ItemFlavor_GetAsset( flav )
		int eventTileType = GetGlobalSettingsInt( tileAsset, "eventTileType" )

		switch( eventTileType )
		{
			case eEventTileType.BUFFET:
				asset buffetEventAsset = GetGlobalSettingsAsset( tileAsset, "linkedBuffetEvent" )
				Assert( buffetEventAsset != $"", format( "Tile Flav %i has an invalid a linked Buffet Event!", flav.guid ) )
				ItemFlavor buffetEventFlav = GetItemFlavorByAsset( buffetEventAsset )
				if ( !CalEvent_IsActive( buffetEventFlav, now ) )
				{
					continue
				}

				
				blocks.extend( BlockBuild_BuffetEventDailies( buffetEventFlav ) )

				break
			case eEventTileType.EVENT_SHOP:
				asset eventShopAsset = GetGlobalSettingsAsset( tileAsset, "linkedEventShop" )
				Assert( eventShopAsset != $"", format( "Tile Flav %i has an invalid a linked Event Shop!", flav.guid ) )
				ItemFlavor eventShopFlav = GetItemFlavorByAsset( eventShopAsset )
				if ( !CalEvent_IsActive( eventShopFlav, now ) )
				{
					continue
				}

				
				blocks.extend( BlockBuild_EventShopDailies( player, eventShopFlav ) )

				break
			case eEventTileType.CUSTOM:
				
				break
			default:
				break
		}
	}

	return blocks
}



array<ChallengeBlock> function BlockBuild_NarrativeSummaryBlock()
{
	array<ChallengeBlock> blocks = []
	array<ItemFlavor> narrativeChallenges = Narrative_GetAllUnlockedNarrativeChallenges()
	if ( narrativeChallenges.len() > 0 )
	{
		ChallengeBlock block = BlockBuild_Default()
		block.title = "#NARRATIVE_SUMMARY_BLOCK_TITLE"
		block.challenges = narrativeChallenges
		blocks.append( block )
		block.customBlockSort = ChallengeBlock_SortNarrativeBlock
		return blocks
	}
	return []
}



ChallengeBlock function BlockBuild_MetaBlock( ItemFlavor collectionMetaChallengeFlav )
{
	ChallengeBlock block = BlockBuild_Default()
	block.isMetaBlock = true
	block.title = ItemFlavor_GetLongName( collectionMetaChallengeFlav )
	block.challenges.append( collectionMetaChallengeFlav )
	return block
}



string function BlockBuild_LocalizeDailyBlockTitle( string categoryOrEventName )
{
	return Localize( "#BLOCK_EVENT_DAILIES_TITLE", Localize( categoryOrEventName ) )
}



asset function ItemFlavor_GetChallengeRewardButtonImage( ItemFlavor flavor )
{
	asset image = ItemFlavor_GetChallengeIcon( flavor )
	if ( image == "" )
	{
		image = CustomizeMenu_GetRewardButtonImage( flavor )
	}
	return image
}



void function ChallengeTile_PrintBlock( ChallengeBlock block )
{
	string fn = FUNC_NAME()
	printf( "%s: Block %s\n", fn, block.title )
	foreach( challenge in block.challenges )
	{
		printf( "%s:\tChallenge %i", fn, challenge.guid )
	}
}

void function ChallengeTile_PrintTile( ChallengeTile tile )
{
	string fn = FUNC_NAME()
	printf( "%s: Tile %i: %s------\n", fn, tile.tileId, tile.title )
	printf( "%s: tileCategory: %i \n", fn, tile.tileCategory )
	printf( "%s: startDate: %i, endDate: %i \n", fn, tile.startDate, tile.endDate )
	printf( "%s: featuredRewards: %s \n", fn, tile.featuredRewards )
	printf( "%s: Blocks: \n", fn )
	foreach( block in tile.blocks )
	{
		ChallengeTile_PrintBlock( block )
	}

	if ( ChallengeTile_HasDeepLink( tile ) )
	{
		printf( "%s: linkType: %s \n", fn, tile.deepLinkConfig.linkType )
		printf( "%s: link: %s \n", fn, tile.deepLinkConfig.link )
		printf( "%s: label: %s \n", fn, tile.deepLinkConfig.label )
	}


	printf( "%s: Tile %i end------", fn, tile.tileId )
}

#if DEV
	void function ChallengeTile_PrintTiles()
	{
		printf( "%s: %i tiles \n", FUNC_NAME(), file.activeTiles.len() )
		foreach( tile in file.activeTiles )
		{
			ChallengeTile_PrintTile( tile )
		}

	}
#endif

                                